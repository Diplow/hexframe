#!/bin/sh
#
# Architecture Boundary Check - Fast Python Implementation with Bash Fallback
# 
# Usage:
#   pnpm check:architecture [path]     # Recommended: uses pnpm environment
#   bash .husky/check-architecture     # Direct execution (may fail if tools not in PATH)
#
# CORE PRINCIPLE: Boundaries are complexity inflection points. When this script
# fails, it's a signal to pause and consider if we're adding necessary complexity.
#
# SUBSYSTEM DEFINITION:
# - Identified by dependencies.json file (not interface.ts)
# - All external imports must be explicitly allowed
# - Parent defines child subsystems in "subsystems" array
#
# DOMAIN SPECIAL RULES (src/lib/domains/*):
# - Services: backend-only, exposed via services/index.ts, each service is a subsystem
# - Infrastructure: each folder is a subsystem with dependencies.json
# - Utils: client-safe, exposed via utils/index.ts
# - _objects imports are automatically allowed for domain children
#
# PATH HIERARCHY LOGIC:
# - If ~/lib/utils is allowed, automatically allows ~/lib/utils/* 
# - Exception: Subsystems in allowed paths still need explicit permission
# - Example: ~/app/map allows ~/app/map/types but NOT ~/app/map/Cache (subsystem)
#
# Default path: src

set -e

# Try Python implementation first (much faster), fallback to bash
if command -v python3 >/dev/null 2>&1 && [ -f "scripts/check-architecture.py" ]; then
    python3 scripts/check-architecture.py "$@"
    exit $?
fi

echo "‚ö†Ô∏è  Python3 not available or scripts/check-architecture.py missing, using bash fallback..."
echo "   (This will be slower - consider installing Python3 for better performance)"
echo ""

# Get target path from argument or default to src
TARGET_PATH=${1:-src}

echo "üèóÔ∏è Checking architectural boundaries in $TARGET_PATH..."

# Configuration
COMPLEXITY_THRESHOLD=1000  # Lines before requiring subsystem structure
DOC_THRESHOLD=500          # Lines before requiring README

# Load exceptions from .architecture-ignore file if it exists
load_exceptions() {
  if [ -f ".architecture-ignore" ]; then
    grep -v '^#' .architecture-ignore 2>/dev/null | grep -v '^$' || echo ""
  else
    echo "src/components"
  fi
}

# Check if a path matches any exception pattern
is_exception() {
  local path=$1
  local exceptions=$(load_exceptions)
  
  if [ -z "$exceptions" ]; then
    return 1
  fi
  
  while IFS= read -r pattern; do
    if [ -z "$pattern" ]; then
      continue
    fi
    case "$path" in
      $pattern)
        return 0
        ;;
    esac
  done <<< "$exceptions"
  
  return 1
}

# Check if path is in a domain
is_domain_path() {
  local path=$1
  case "$path" in
    src/lib/domains/*)
      return 0
      ;;
  esac
  return 1
}

# Get domain type based on path
get_domain_type() {
  local path=$1
  case "$path" in
    */services/*)
      echo "service"
      ;;
    */infrastructure/*)
      echo "infrastructure"
      ;;
    */utils/*)
      echo "utils"
      ;;
    *)
      echo "unknown"
      ;;
  esac
}

# Count TypeScript lines in a directory
# Recursive, but stops at subsystem boundaries (folders with dependencies.json)
count_ts_lines() {
  local dir=$1
  local total=0
  
  # Count direct files in this directory
  local direct_lines=$(find "$dir" -maxdepth 1 -type f \( -name "*.ts" -o -name "*.tsx" \) -not -name "*.test.*" -not -name "*.spec.*" 2>/dev/null | \
    xargs wc -l 2>/dev/null | \
    tail -1 | \
    awk '{print $1}' || echo 0)
  
  total=$((total + direct_lines))
  
  # For each subdirectory, check if it's a subsystem boundary
  for subdir in "$dir"/*; do
    if [ -d "$subdir" ]; then
      # If subfolder has dependencies.json, it's its own subsystem - don't count it
      if [ -f "$subdir/dependencies.json" ]; then
        continue  # Skip this subfolder, it's a separate subsystem
      else
        # Not a subsystem, count its lines recursively
        subdir_lines=$(count_ts_lines "$subdir")
        total=$((total + subdir_lines))
      fi
    fi
  done
  
  echo $total
}

# Check if a path is allowed through hierarchy or explicit declaration
is_path_allowed() {
  local import_path=$1
  local allowed_deps=$2
  local subsystem_dir=$3
  
  # Convert subsystem_dir to absolute path format for comparison
  local subsystem_abs_path=""
  if [[ "$subsystem_dir" == src/* ]]; then
    subsystem_abs_path="~/${subsystem_dir#src/}"
  else
    subsystem_abs_path="$subsystem_dir"
  fi
  
  # Allow internal imports within the same subsystem
  case "$import_path" in
    "$subsystem_abs_path"*)
      return 0  # Internal import
      ;;
  esac
  
  if [ -z "$allowed_deps" ]; then
    return 1
  fi
  
  # Check direct matches first
  IFS='|' read -ra DEPS <<< "$allowed_deps"
  for allowed_dep in "${DEPS[@]}"; do
    case "$import_path" in
      "$allowed_dep")
        return 0  # Exact match
        ;;
      "$allowed_dep"*)
        # Check if it's a hierarchical match
        # If allowed path is ~/lib/utils, allow ~/lib/utils/something
        # But NOT if the child is a subsystem
        local child_path=$(echo "$import_path" | sed "s|^$allowed_dep/||" | sed "s|^$allowed_dep||")
        
        # If there's no child path, it's an exact match
        if [ -z "$child_path" ] || [ "$child_path" = "$import_path" ]; then
          return 0
        fi
        
        # Check if the child path contains a subsystem
        # Look for dependencies.json in the child path
        local potential_subsystem_path=""
        if [[ "$allowed_dep" == ~/* ]]; then
          # Convert ~/path to src/path for file system checking
          potential_subsystem_path="src/${allowed_dep#\~/}/$child_path"
        else
          potential_subsystem_path="$allowed_dep/$child_path"
        fi
        
        # If child is a subsystem (has dependencies.json), require explicit permission
        if [ -f "$potential_subsystem_path/dependencies.json" ]; then
          return 1  # Child is subsystem, needs explicit permission
        fi
        
        # Otherwise, hierarchy allows it
        return 0
        ;;
    esac
  done
  
  return 1  # Not allowed
}

# Resolve full inheritance chain of allowedChildren from all ancestors
resolve_full_inheritance_chain() {
  local subsystem_dir=$1
  local all_inherited=""
  
  # Walk up the directory tree to find all parents with dependencies.json
  local current_dir="$subsystem_dir"
  
  while true; do
    local parent_dir=$(dirname "$current_dir")
    
    # Stop if we've reached src or root (don't stop at TARGET_PATH)
    if [ "$parent_dir" = "src" ] || [ "$parent_dir" = "/" ] || [ "$parent_dir" = "." ] || [ "$parent_dir" = "$current_dir" ]; then
      break
    fi
    
    local parent_deps_file="$parent_dir/dependencies.json"
    if [ -f "$parent_deps_file" ]; then
      # Extract allowedChildren from this parent
      local parent_allowed_children=""
      if command -v jq >/dev/null 2>&1; then
        parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
      else
        parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
      fi
      
      # Add to inherited chain
      if [ -n "$parent_allowed_children" ]; then
        if [ -n "$all_inherited" ]; then
          all_inherited="$all_inherited|$parent_allowed_children"
        else
          all_inherited="$parent_allowed_children"
        fi
      fi
    fi
    
    current_dir="$parent_dir"
  done
  
  echo "$all_inherited"
}

# Load and resolve subsystem dependencies
resolve_allowed_dependencies() {
  local deps_file=$1
  local parent_allowed_children=$2
  
  if [ ! -f "$deps_file" ]; then
    echo ""
    return
  fi
  
  local allowed=""
  local allowed_children=""
  
  # Extract allowed dependencies
  if command -v jq >/dev/null 2>&1; then
    allowed=$(jq -r '.allowed[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    allowed_children=$(jq -r '.allowedChildren[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
  else
    # Fallback to grep/sed parsing - extract array values only
    allowed=$(sed -n '/"allowed":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    allowed_children=$(sed -n '/"allowedChildren":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
  fi
  
  # Combine allowed, allowedChildren, and parent allowedChildren
  local combined=""
  [ -n "$allowed" ] && combined="$allowed"
  [ -n "$allowed_children" ] && combined="$combined|$allowed_children"
  [ -n "$parent_allowed_children" ] && combined="$combined|$parent_allowed_children"
  
  # For domain subsystems, automatically add _objects
  local subsystem_dir=$(dirname "$deps_file")
  if is_domain_path "$subsystem_dir"; then
    combined="$combined|_objects"
  fi
  
  echo "$combined" | sed 's/^|//' | sed 's/|$//'
}

# Find all subsystems (directories with dependencies.json)
find_subsystems() {
  find "$TARGET_PATH" -name "dependencies.json" -not -path "*/node_modules/*" 2>/dev/null | while read deps_file; do
    dirname "$deps_file"
  done
}

# Check for file/folder naming conflicts
check_file_folder_conflicts() {
  local target_path=$1
  local conflicts=""
  
  # Find all TypeScript files
  find "$target_path" -type f \( -name "*.ts" -o -name "*.tsx" \) -not -path "*/node_modules/*" -not -path "*/.git/*" | while read ts_file; do
    # Get the directory containing this file
    file_dir=$(dirname "$ts_file")
    # Get the basename without extension  
    file_basename=$(basename "$ts_file" .ts)
    file_basename=$(basename "$file_basename" .tsx)
    
    # Skip index files as they're the recommended pattern
    if [ "$file_basename" = "index" ]; then
      continue
    fi
    
    # Check if there's a folder with the same name in the same directory
    potential_folder="$file_dir/$file_basename"
    if [ -d "$potential_folder" ]; then
      # Write conflict to temporary file (due to subshell limitations)
      relative_file=$(echo "$ts_file" | sed "s|^$TARGET_PATH/||")
      relative_folder=$(echo "$potential_folder" | sed "s|^$TARGET_PATH/||")
      echo "‚ùå File/folder naming conflict:" >> "/tmp/naming_conflicts_$$"
      echo "  üî∏ File: $relative_file" >> "/tmp/naming_conflicts_$$" 
      echo "  üî∏ Folder: $relative_folder/" >> "/tmp/naming_conflicts_$$"
      echo "     ‚Üí Move file contents to $relative_folder/index.ts" >> "/tmp/naming_conflicts_$$"
      echo "" >> "/tmp/naming_conflicts_$$"
    fi
  done
}

# Validate domain-specific structure
validate_domain_structure() {
  local domain_path=$1
  
  # Check if services are properly structured
  if [ -d "$domain_path/services" ]; then
    # Each service file should have its own dependencies.json
    find "$domain_path/services" -maxdepth 1 -name "*.ts" -not -name "index.ts" | while read service_file; do
      service_name=$(basename "$service_file" .ts)
      if [ ! -f "$domain_path/services/dependencies.json" ]; then
        ERRORS="${ERRORS}${NEWLINE}‚ùå Service $service_file needs its own dependencies.json in services/"
      fi
    done
    
    # Services must be exposed in services/index.ts
    if [ ! -f "$domain_path/services/index.ts" ]; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå $domain_path/services missing index.ts to expose services"
    fi
  fi
  
  # Check infrastructure structure
  find "$domain_path" -mindepth 3 -path "*/infrastructure/*" -type d | while read infra_dir; do
    if [ ! -f "$infra_dir/dependencies.json" ]; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå Infrastructure $infra_dir needs dependencies.json"
    fi
  done
  
  # Check utils structure
  if [ -d "$domain_path/utils" ]; then
    if [ ! -f "$domain_path/utils/index.ts" ]; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå $domain_path/utils missing index.ts to expose utilities"
    fi
  fi
}

ERRORS=""
WARNINGS=""
NEWLINE=$'\n'

# Check all directories for complexity requirements
echo "Scanning directories for complexity requirements..."
for dir in $(find "$TARGET_PATH" -type d -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*"); do
  if is_exception "$dir"; then
    continue
  fi
  
  # Skip if this is a child of a subsystem (would be double-counted)
  parent_dir=$(dirname "$dir")
  if [ -f "$parent_dir/dependencies.json" ]; then
    if [ "$parent_dir" != "$dir" ]; then
      continue
    fi
  fi
  
  lines=$(count_ts_lines "$dir")
  
  if [ "$lines" -gt "$COMPLEXITY_THRESHOLD" ]; then
    # Complex folder - needs full subsystem structure
    missing=""
    [ ! -f "$dir/dependencies.json" ] && missing="$missing dependencies.json"
    [ ! -f "$dir/README.md" ] && missing="$missing README.md"
    [ ! -f "$dir/ARCHITECTURE.md" ] && missing="$missing ARCHITECTURE.md"
    
    if [ -n "$missing" ]; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå $dir ($lines lines) missing:$missing"
    fi
    
  elif [ "$lines" -gt "$DOC_THRESHOLD" ]; then
    # Medium complexity - just needs README
    if [ ! -f "$dir/README.md" ]; then
      WARNINGS="${WARNINGS}${NEWLINE}‚ö†Ô∏è  $dir ($lines lines) - missing README.md"
    fi
  fi
done

# Check that subsystems have all required files
echo "Checking subsystems for completeness..."
find_subsystems | while read subsystem_dir; do
  missing=""
  [ ! -f "$subsystem_dir/README.md" ] && missing="$missing README.md"
  [ ! -f "$subsystem_dir/ARCHITECTURE.md" ] && missing="$missing ARCHITECTURE.md"
  
  if [ -n "$missing" ]; then
    ERRORS="${ERRORS}${NEWLINE}‚ùå Subsystem $subsystem_dir missing:$missing"
  fi
done

# Check that subsystems are declared in their parent's dependencies.json
echo "Checking subsystem declarations..."
find_subsystems | while read subsystem_dir; do
  parent_dir=$(dirname "$subsystem_dir")
  
  # Skip if parent is the target path itself
  if [ "$parent_dir" = "$TARGET_PATH" ] || [ "$parent_dir" = "." ]; then
    continue
  fi
  
  parent_deps_file="$parent_dir/dependencies.json"
  if [ -f "$parent_deps_file" ]; then
    relative_path=$(echo "$subsystem_dir" | sed "s|$parent_dir/|./|")
    
    if ! grep -q "\"$relative_path\"" "$parent_deps_file" 2>/dev/null; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå Subsystem $subsystem_dir not declared in $parent_deps_file"
      ERRORS="${ERRORS}${NEWLINE}   ‚Üí Add \"$relative_path\" to the \"subsystems\" array"
    fi
  fi
done

# Check import boundaries for subsystems
echo "Checking import boundaries..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  parent_dir=$(dirname "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  
  # Get parent's allowedChildren
  parent_deps_file="$parent_dir/dependencies.json"
  parent_allowed_children=""
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # Check external imports (from completely outside the parent system)
  violations=$(find src -name "*.ts" -o -name "*.tsx" | \
    xargs grep -l "from [\"']~/.*/$subsystem_name/" 2>/dev/null | \
    grep -v "^$subsystem_dir/" | \
    grep -v "^$parent_dir/" | \
    xargs grep -H "from [\"']~/.*/$subsystem_name/[^\"']*[\"']" 2>/dev/null | \
    grep -v "/$subsystem_name[\"']" | \
    grep -v "/$subsystem_name/index[\"']" || true)
  
  if [ -n "$violations" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}‚ùå External imports bypass $subsystem_name/index:"
    while IFS= read -r violation; do
      if [ -n "$violation" ]; then
        file=$(echo "$violation" | cut -d: -f1)
        import_line=$(echo "$violation" | cut -d: -f2-)
        import_clean=$(echo "$import_line" | sed 's/^[[:space:]]*//' | sed 's/;$//')
        ERRORS="${ERRORS}${NEWLINE}  üî∏ $file${NEWLINE}     $import_clean"
      fi
    done << EOF
$violations
EOF
  fi
  
  # Check parent imports - should use relative index
  parent_violations=$(find "$parent_dir" -maxdepth 1 -name "*.ts" -o -name "*.tsx" | \
    xargs grep -H "from [\"']\.\.*/$subsystem_name/[^\"']*[\"']" 2>/dev/null | \
    grep -v "/$subsystem_name[\"']" | \
    grep -v "/$subsystem_name/index[\"']" || true)
  
  if [ -n "$parent_violations" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}‚ùå Parent system imports bypass $subsystem_name/index:"
    while IFS= read -r violation; do
      if [ -n "$violation" ]; then
        file=$(echo "$violation" | cut -d: -f1)
        import_line=$(echo "$violation" | cut -d: -f2-)
        import_clean=$(echo "$import_line" | sed 's/^[[:space:]]*//' | sed 's/;$//')
        ERRORS="${ERRORS}${NEWLINE}  üî∏ $file${NEWLINE}     $import_clean${NEWLINE}     ‚Üí Should use: from './$subsystem_name'"
      fi
    done << EOF
$parent_violations
EOF
  fi
done

# Check that dependencies.json files use absolute paths
echo "Checking dependencies.json path format..."
find_subsystems | while read subsystem_dir; do
  deps_file="$subsystem_dir/dependencies.json"
  
  if [ -f "$deps_file" ]; then
    # Check for relative paths in allowed array
    relative_paths=$(grep -n '"\.\./' "$deps_file" 2>/dev/null | grep -v '"subsystems"' || true)
    relative_current_paths=$(grep -n '"\\./' "$deps_file" 2>/dev/null | grep -v '"subsystems"' || true)
    
    if [ -n "$relative_paths" ]; then
      while IFS= read -r line; do
        if [ -n "$line" ]; then
          line_num=$(echo "$line" | cut -d: -f1)
          path_content=$(echo "$line" | cut -d: -f2-)
          ERRORS="${ERRORS}${NEWLINE}‚ùå Relative path in $deps_file:$line_num"
          ERRORS="${ERRORS}${NEWLINE}  $path_content"
          ERRORS="${ERRORS}${NEWLINE}   ‚Üí Use absolute paths with ~/ prefix instead"
        fi
      done << EOF
$relative_paths
EOF
    fi
    
    if [ -n "$relative_current_paths" ]; then
      while IFS= read -r line; do
        if [ -n "$line" ]; then
          # Skip subsystems array - those should remain relative
          if echo "$line" | grep -q '"subsystems"' || echo "$line" | grep -q 'subsystem'; then
            continue
          fi
          
          line_num=$(echo "$line" | cut -d: -f1)
          path_content=$(echo "$line" | cut -d: -f2-)
          ERRORS="${ERRORS}${NEWLINE}‚ùå Relative current dir path in $deps_file:$line_num"
          ERRORS="${ERRORS}${NEWLINE}  $path_content"
          ERRORS="${ERRORS}${NEWLINE}   ‚Üí Use absolute paths with ~/ prefix instead (except for subsystems)"
        fi
      done << EOF
$relative_current_paths
EOF
    fi
  fi
done

# Check for redundant dependencies (child redeclaring parent allowedChildren)
echo "Checking for redundant dependency declarations..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  parent_dir=$(dirname "$subsystem_dir")
  
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Get parent's allowedChildren
  parent_deps_file="$parent_dir/dependencies.json"
  parent_allowed_children=""
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # If parent has allowedChildren, check child's allowed array for conflicts
  if [ -n "$parent_allowed_children" ]; then
    # Get child's allowed dependencies
    child_allowed=""
    if command -v jq >/dev/null 2>&1; then
      child_allowed=$(jq -r '.allowed[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      child_allowed=$(sed -n '/"allowed":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
    
    # Check each child allowed dependency against parent allowedChildren
    if [ -n "$child_allowed" ]; then
      IFS='|' read -ra CHILD_DEPS <<< "$child_allowed"
      
      for child_dep in "${CHILD_DEPS[@]}"; do
        # Use exact match with pipe delimiters as word boundaries
        if echo "|$parent_allowed_children|" | grep -q "|$child_dep|"; then
          echo "‚ùå Redundant dependency in $subsystem_name:" >> "/tmp/redundant_deps_$$"
          echo "  üî∏ '$child_dep' is already provided by parent allowedChildren" >> "/tmp/redundant_deps_$$"
          echo "     ‚Üí Remove from $deps_file 'allowed' array" >> "/tmp/redundant_deps_$$"
          echo "     ‚Üí Parent allowedChildren automatically cascades to children" >> "/tmp/redundant_deps_$$"
          echo "" >> "/tmp/redundant_deps_$$"
        fi
      done
    fi
  fi
done

# Check for redundant allowedChildren (child redeclaring parent allowedChildren)
echo "Checking for redundant allowedChildren declarations..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  parent_dir=$(dirname "$subsystem_dir")
  
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Get parent's allowedChildren
  parent_deps_file="$parent_dir/dependencies.json"
  parent_allowed_children=""
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # If parent has allowedChildren, check child's allowedChildren array for conflicts
  if [ -n "$parent_allowed_children" ]; then
    # Get child's allowedChildren dependencies
    child_allowed_children=""
    if command -v jq >/dev/null 2>&1; then
      child_allowed_children=$(jq -r '.allowedChildren[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      child_allowed_children=$(sed -n '/"allowedChildren":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
    
    # Check each child allowedChildren dependency against parent allowedChildren
    if [ -n "$child_allowed_children" ]; then
      IFS='|' read -ra CHILD_ALLOWED_CHILDREN <<< "$child_allowed_children"
      
      for child_dep in "${CHILD_ALLOWED_CHILDREN[@]}"; do
        # Use exact match with pipe delimiters as word boundaries
        if echo "|$parent_allowed_children|" | grep -q "|$child_dep|"; then
          echo "‚ùå Redundant allowedChildren in $subsystem_name:" >> "/tmp/redundant_allowed_children_$$"
          echo "  üî∏ '$child_dep' is already provided by parent allowedChildren" >> "/tmp/redundant_allowed_children_$$"
          echo "     ‚Üí Remove from $deps_file 'allowedChildren' array" >> "/tmp/redundant_allowed_children_$$"
          echo "     ‚Üí Parent allowedChildren automatically cascades to children" >> "/tmp/redundant_allowed_children_$$"
          echo "" >> "/tmp/redundant_allowed_children_$$"
        fi
      done
    fi
  fi
done

# Check for hierarchical redundancy (child declaring sub-paths of parent allowedChildren)
echo "Checking for hierarchical redundancy..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  parent_dir=$(dirname "$subsystem_dir")
  
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Get parent's allowedChildren
  parent_deps_file="$parent_dir/dependencies.json"
  parent_allowed_children=""
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # If parent has allowedChildren, check child's dependencies for hierarchical redundancy
  if [ -n "$parent_allowed_children" ]; then
    # Get all child dependencies (both allowed and allowedChildren)
    child_all_deps=""
    if command -v jq >/dev/null 2>&1; then
      child_allowed=$(jq -r '.allowed[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
      child_allowed_children=$(jq -r '.allowedChildren[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      child_allowed=$(sed -n '/"allowed":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
      child_allowed_children=$(sed -n '/"allowedChildren":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
    
    # Combine both arrays
    if [ -n "$child_allowed" ] && [ -n "$child_allowed_children" ]; then
      child_all_deps="$child_allowed|$child_allowed_children"
    elif [ -n "$child_allowed" ]; then
      child_all_deps="$child_allowed"
    elif [ -n "$child_allowed_children" ]; then
      child_all_deps="$child_allowed_children"
    fi
    
    # Check each child dependency against parent allowedChildren for hierarchical matches
    if [ -n "$child_all_deps" ]; then
      IFS='|' read -ra CHILD_ALL_DEPS <<< "$child_all_deps"
      IFS='|' read -ra PARENT_ALLOWED_CHILDREN <<< "$parent_allowed_children"
      
      for child_dep in "${CHILD_ALL_DEPS[@]}"; do
        for parent_dep in "${PARENT_ALLOWED_CHILDREN[@]}"; do
          # Check if child dependency starts with parent dependency
          case "$child_dep" in
            "$parent_dep"/*)
              # Child is a sub-path of parent allowedChildren
              # But check if it's a subsystem that needs explicit permission
              potential_subsystem_path=""
              if [[ "$parent_dep" == ~/* ]]; then
                # Convert ~/path to src/path for file system checking
                parent_fs_path="src/${parent_dep#\~/}"
                child_suffix="${child_dep#$parent_dep/}"
                potential_subsystem_path="$parent_fs_path/$child_suffix"
              else
                potential_subsystem_path="$parent_dep/${child_dep#$parent_dep/}"
              fi
              
              # If child path is NOT a subsystem, it's redundant
              if [ ! -f "$potential_subsystem_path/dependencies.json" ]; then
                # Determine which array the dependency is in
                dep_array="unknown"
                if echo "|$child_allowed|" | grep -q "|$child_dep|"; then
                  dep_array="allowed"
                elif echo "|$child_allowed_children|" | grep -q "|$child_dep|"; then
                  dep_array="allowedChildren"
                fi
                
                echo "‚ùå Hierarchical redundancy in $subsystem_name:" >> "/tmp/hierarchical_redundancy_$$"
                echo "  üî∏ '$child_dep' is covered by parent's '$parent_dep'" >> "/tmp/hierarchical_redundancy_$$"
                echo "     ‚Üí Remove from $deps_file '$dep_array' array" >> "/tmp/hierarchical_redundancy_$$"
                echo "     ‚Üí Parent allowedChildren '$parent_dep' already allows access to sub-paths" >> "/tmp/hierarchical_redundancy_$$"
                echo "" >> "/tmp/hierarchical_redundancy_$$"
              fi
              ;;
          esac
        done
      done
    fi
  fi
done

# Read redundant dependencies file and add to ERRORS
if [ -f "/tmp/redundant_deps_$$" ]; then
  redundant_errors=$(cat "/tmp/redundant_deps_$$")
  if [ -n "$redundant_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$redundant_errors"
  fi
  rm -f "/tmp/redundant_deps_$$"
fi

# Read redundant allowedChildren file and add to ERRORS
if [ -f "/tmp/redundant_allowed_children_$$" ]; then
  redundant_allowed_children_errors=$(cat "/tmp/redundant_allowed_children_$$")
  if [ -n "$redundant_allowed_children_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$redundant_allowed_children_errors"
  fi
  rm -f "/tmp/redundant_allowed_children_$$"
fi

# Read hierarchical redundancy file and add to ERRORS
if [ -f "/tmp/hierarchical_redundancy_$$" ]; then
  hierarchical_redundancy_errors=$(cat "/tmp/hierarchical_redundancy_$$")
  if [ -n "$hierarchical_redundancy_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$hierarchical_redundancy_errors"
  fi
  rm -f "/tmp/hierarchical_redundancy_$$"
fi

# Check hierarchical dependency violations
echo "Checking hierarchical dependencies..."

# Helper function to count path depth (number of ../ segments)
count_path_depth() {
  local path="$1"
  echo "$path" | grep -o "\.\.\/" | wc -l
}

# Helper function to check if a path goes beyond direct children
is_hierarchical_violation() {
  local import_path="$1"
  local subsystem_dir="$2"
  
  # Skip non-relative imports
  case "$import_path" in
    "../"*)
      # PHILOSOPHY: 
      # - Going UP the hierarchy (../../../parent) is ALWAYS allowed
      # - Going DOWN/ACROSS to grandchildren (../sibling/grandchild) is FORBIDDEN
      
      # Check if path goes DOWN after going UP
      # Pattern: ../[directory]/[directory] means "go up, then down into sibling, then down into grandchild"
      # But ../../.. or ../../../types means "just go up multiple levels" which is fine
      
      # Remove all leading ../ segments to see what's left
      local path_after_ups=$(echo "$import_path" | sed 's|^\(\.\./\)*||')
      
      # If what's left contains multiple directory levels, it's going down through grandchildren
      # Count slashes in the remaining path - more than 1 slash means multiple levels down
      local slash_count=$(echo "$path_after_ups" | tr -cd '/' | wc -c)
      
      if [ "$slash_count" -gt 1 ]; then
        return 0  # Is a violation - going down through multiple subsystem levels
      fi
      ;;
  esac
  
  return 1  # Not a violation
}

# Helper function to resolve relative import paths to absolute paths
resolve_import_path() {
  local import_path="$1"
  local current_subsystem_dir="$2"
  
  # If already absolute path with ~/, return as-is
  if echo "$import_path" | grep -q "^~/"; then
    echo "$import_path"
    return
  fi
  
  # Resolve relative path
  if echo "$import_path" | grep -q "^\.\."; then
    # Get the absolute path of the current subsystem
    local abs_current=$(cd "$current_subsystem_dir" && pwd)
    # Remove the src/ prefix and add ~/
    local relative_current=$(echo "$abs_current" | sed 's|.*/src/|~/|')
    
    # Count ../ segments
    local up_count=$(echo "$import_path" | grep -o "\.\.\/" | wc -l)
    
    # Remove ../ segments from current path
    local resolved_base="$relative_current"
    for i in $(seq 1 $up_count); do
      resolved_base=$(dirname "$resolved_base")
    done
    
    # Add the remaining path after ../
    local remaining_path=$(echo "$import_path" | sed 's|\.\./||g')
    if [ -n "$remaining_path" ]; then
      echo "$resolved_base/$remaining_path"
    else
      echo "$resolved_base"
    fi
  else
    # Relative path without ../ - should not happen in outbound imports
    echo "$import_path"
  fi
}

# Helper function to check if import is allowed by dependencies.json
is_import_allowed() {
  local import_path="$1"
  local deps_file="$2"
  
  # Read allowed dependencies from JSON
  local allowed_deps=""
  if command -v jq >/dev/null 2>&1; then
    allowed_deps=$(jq -r '.allowed[]?' "$deps_file" 2>/dev/null || echo "")
  else
    # Fallback parsing without jq
    allowed_deps=$(grep -o '"[^"]*"' "$deps_file" | grep -A 100 '"allowed"' | grep -v '"allowed"' | head -n 50 | sed 's/"//g' || echo "")
  fi
  
  # Check direct matches
  if echo "$allowed_deps" | grep -q "^${import_path}$"; then
    return 0  # Allowed
  fi
  
  # Check hierarchical matches (if ~/lib/utils is allowed, ~/lib/utils/cn should be allowed)
  while IFS= read -r allowed_dep; do
    if [ -n "$allowed_dep" ] && echo "$import_path" | grep -q "^${allowed_dep}/"; then
      return 0  # Allowed by hierarchy
    fi
  done << EOF
$allowed_deps
EOF
  
  return 1  # Not allowed
}

# Helper function to check if import is allowed by resolved dependencies (pipe-separated)
is_import_allowed_by_resolved() {
  local import_path="$1"
  local resolved_deps="$2"
  
  if [ -z "$resolved_deps" ]; then
    return 1  # No dependencies resolved
  fi
  
  # Check direct match using pipe delimiters
  if echo "|$resolved_deps|" | grep -q "|$import_path|"; then
    return 0  # Exact match found
  fi
  
  # Check hierarchical matches (if ~/lib/utils is allowed, ~/lib/utils/something should be allowed)
  IFS='|' read -ra DEPS <<< "$resolved_deps"
  for allowed_dep in "${DEPS[@]}"; do
    if [ -n "$allowed_dep" ]; then
      # Handle both ~/path and ~/path/ forms
      local normalized_dep="${allowed_dep%/}"  # Remove trailing slash if present
      if echo "$import_path" | grep -q "^${normalized_dep}/"; then
        return 0  # Allowed by hierarchy
      fi
    fi
  done
  
  return 1  # Not allowed
}

# Helper function to find the top-level subsystem containing a path
find_top_level_subsystem() {
  local target_path="$1"
  local original_target="$target_path"
  
  # Convert ~/path to src/path for file system checking
  if [[ "$target_path" == \~/* ]]; then
    target_path="${target_path/\~\//src/}"
  fi
  
  # Special handling for major areas - look for the top-level subsystem
  # For src/app/map/... paths, we want to find src/app/map as the boundary
  # For src/lib/... paths, we want to find src/lib as the boundary
  
  # Check specific patterns for known top-level subsystems
  case "$target_path" in
    src/app/map/*)
      if [ -f "src/app/map/dependencies.json" ]; then
        echo "src/app/map"
        return 0
      fi
      ;;
    src/lib/*)
      # For lib, the first level is the boundary (src/lib/domains, src/lib/utils, etc.)
      echo "$target_path" | sed 's|^src/lib/\([^/]*\).*|src/lib/\1|'
      return 0
      ;;
    src/commons/*)
      echo "$target_path" | sed 's|^src/commons/\([^/]*\).*|src/commons/\1|'
      return 0
      ;;
    src/components/*)
      echo "src/components"
      return 0
      ;;
  esac
  
  # Fallback: find the nearest subsystem by walking up
  local current_dir="$target_path"
  while [ "$current_dir" != "src" ] && [ "$current_dir" != "/" ] && [ "$current_dir" != "." ]; do
    if [ -f "$current_dir/dependencies.json" ]; then
      echo "$current_dir"
      return 0
    fi
    current_dir=$(dirname "$current_dir")
  done
  
  # Final fallback: return the immediate child of src
  if [[ "$target_path" == src/* ]]; then
    echo "$target_path" | sed 's|^src/\([^/]*\).*|src/\1|'
  else
    echo "$original_target"
  fi
}

# Helper function to check if an import is truly outbound (crosses subsystem boundaries)
is_truly_outbound() {
  local import_path="$1"
  local current_subsystem_dir="$2"
  
  # Skip non-absolute imports (relative imports like ../ are handled separately)
  if [[ "$import_path" != \~/* ]]; then
    return 0  # Consider relative imports as potentially outbound
  fi
  
  # Find the top-level subsystem containing the current file
  local current_top_subsystem=$(find_top_level_subsystem "$current_subsystem_dir")
  
  # Find the top-level subsystem containing the import target
  local import_target_subsystem=$(find_top_level_subsystem "$import_path")
  
  # If both are in the same top-level subsystem, it's internal
  if [ "$current_top_subsystem" = "$import_target_subsystem" ]; then
    return 1  # Not outbound - internal to same subsystem
  fi
  
  return 0  # Truly outbound - crosses subsystem boundaries
}

# Check outbound dependencies against allowlist
echo "Checking outbound dependencies..."

find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  parent_dir=$(dirname "$subsystem_dir")
  
  # Skip if no dependencies.json
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Get full inheritance chain of allowedChildren from all ancestors
  full_inherited_allowedchildren=$(resolve_full_inheritance_chain "$subsystem_dir")
  
  # Resolve all allowed dependencies (local + inherited from full chain)
  resolved_allowed_deps=$(resolve_allowed_dependencies "$deps_file" "$full_inherited_allowedchildren")
  
  # Find all TypeScript files in the subsystem
  for ts_file in $(find "$subsystem_dir" -name "*.ts" -o -name "*.tsx" | grep -v "__tests__" | grep -v ".test.ts" | grep -v ".spec.ts"); do
    # Find imports that go outside the subsystem
    outbound_imports=$(grep -n "from [\"']\.\./\|from [\"']~/" "$ts_file" 2>/dev/null || true)
    
    if [ -n "$outbound_imports" ]; then
      echo "$outbound_imports" | while IFS= read -r import_line; do
        if [ -n "$import_line" ]; then
          line_num=$(echo "$import_line" | cut -d: -f1)
          import_path=$(echo "$import_line" | sed "s/.*from [\"']\([^\"']*\)[\"'].*/\1/")
          
          # Skip internal imports that don't cross subsystem boundaries
          if ! is_truly_outbound "$import_path" "$subsystem_dir"; then
            continue  # Skip this import - it's internal to the same top-level subsystem
          fi
          
          # Check if this is a hierarchical violation
          if is_hierarchical_violation "$import_path" "$subsystem_dir"; then
            relative_file=$(echo "$ts_file" | sed "s|^$subsystem_dir/||")
            echo "‚ö†Ô∏è Hierarchical dependency violation in $subsystem_name:" >> "/tmp/hierarchical_errors_$$"
            echo "  üî∏ $relative_file:$line_num" >> "/tmp/hierarchical_errors_$$"
            echo "     import from '$import_path'" >> "/tmp/hierarchical_errors_$$"
            echo "     ‚Üí This imports from a grandchild subsystem. Create reexports in intermediate subsystems." >> "/tmp/hierarchical_errors_$$"
            echo "" >> "/tmp/hierarchical_errors_$$"
          fi
          
          # Check if this import is allowed by resolved dependencies (local + inherited)
          resolved_path=$(resolve_import_path "$import_path" "$subsystem_dir")
          if ! is_import_allowed_by_resolved "$resolved_path" "$resolved_allowed_deps"; then
            relative_file=$(echo "$ts_file" | sed "s|^$subsystem_dir/||")
            echo "‚ùå Undeclared outbound dependency in $subsystem_name:" >> "/tmp/dependency_errors_$$"
            echo "  üî∏ $relative_file:$line_num" >> "/tmp/dependency_errors_$$"
            echo "     import from '$import_path' ‚Üí resolves to '$resolved_path'" >> "/tmp/dependency_errors_$$"
            echo "     ‚Üí Add '$resolved_path' to dependencies.json 'allowed' array" >> "/tmp/dependency_errors_$$"
            echo "     ‚Üí Or ensure parent allowedChildren includes this dependency" >> "/tmp/dependency_errors_$$"
            echo "" >> "/tmp/dependency_errors_$$"
          fi
        fi
      done
    fi
  done
done

# Read hierarchical error file and add to ERRORS
if [ -f "/tmp/hierarchical_errors_$$" ]; then
  hierarchical_errors=$(cat "/tmp/hierarchical_errors_$$")
  if [ -n "$hierarchical_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$hierarchical_errors"
  fi
  rm -f "/tmp/hierarchical_errors_$$"
fi

# Read dependency error file and add to ERRORS
if [ -f "/tmp/dependency_errors_$$" ]; then
  dependency_errors=$(cat "/tmp/dependency_errors_$$")
  if [ -n "$dependency_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$dependency_errors"
  fi
  rm -f "/tmp/dependency_errors_$$"
fi

# Check for file/folder naming conflicts
echo "Checking for file/folder naming conflicts..."
check_file_folder_conflicts "$TARGET_PATH"

# Read naming conflicts file and add to ERRORS
if [ -f "/tmp/naming_conflicts_$$" ]; then
  naming_conflicts=$(cat "/tmp/naming_conflicts_$$")
  if [ -n "$naming_conflicts" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$naming_conflicts"
  fi
  rm -f "/tmp/naming_conflicts_$$"
fi

# Validate domain-specific structure
echo "Checking domain structure..."
for domain_dir in $(find "$TARGET_PATH/lib/domains" -mindepth 1 -maxdepth 1 -type d 2>/dev/null); do
  validate_domain_structure "$domain_dir"
done

# Check domain import restrictions
echo "Checking domain import restrictions..."
find "$TARGET_PATH/lib/domains" -path "*/services/*.ts" -not -name "index.ts" 2>/dev/null | while read service_file; do
  # Find files that import this service (should only be API/server files)
  service_imports=$(find src -name "*.ts" -o -name "*.tsx" | \
    xargs grep -l "from.*$(echo "$service_file" | sed 's/.*domains/domains/' | sed 's/\.ts$//')" 2>/dev/null | \
    grep -v "^src/app/api/" | \
    grep -v "^src/server/" | \
    grep -v "$service_file" || true)
  
  if [ -n "$service_imports" ]; then
    service_name=$(basename "$service_file" .ts)
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}‚ùå Service $service_name imported by non-API files:"
    while IFS= read -r importing_file; do
      if [ -n "$importing_file" ]; then
        ERRORS="${ERRORS}${NEWLINE}  üî∏ $importing_file"
        ERRORS="${ERRORS}${NEWLINE}     ‚Üí Services can only be imported by API/server code"
      fi
    done << EOF
$service_imports
EOF
  fi
done

# Report results
if [ -n "$ERRORS" ]; then
  echo ""
  echo "üö® Architecture violations:"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  printf "%s\n" "$ERRORS"
  echo ""
  echo "üìã Requirements:"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  echo "‚Ä¢ Folders over $COMPLEXITY_THRESHOLD lines need:"
  echo "  - dependencies.json"
  echo "  - README.md"
  echo "  - ARCHITECTURE.md"
  echo ""
  echo "‚Ä¢ File/folder naming conflicts:"
  echo "  - If both types.ts and types/ exist, move types.ts content to types/index.ts"
  echo "  - This prevents ambiguous imports and follows the index pattern"
  echo ""
  echo "‚Ä¢ Dependencies.json format:"
  echo "  - All paths in 'allowed' array must use absolute paths with ~/ prefix"
  echo "  - Only 'subsystems' array may use relative paths (./subfolder)"
  echo "  - Example: \"~/lib/utils\" not \"../utils\" or \"./utils\""
  echo ""
  echo "‚Ä¢ Subsystems with dependencies.json must be declared in their parent's \"subsystems\" array"
  echo "‚Ä¢ Subsystems must be imported through their index.ts (renamed from interface.ts)"
  echo "‚Ä¢ External imports should use: import { X } from '~/path/to/subsystem' (automatically uses index.ts)"
  echo "‚Ä¢ Child subsystems cannot redeclare dependencies from parent allowedChildren"
  echo "  - allowedChildren cascade automatically to all children"
  echo "  - Use allowedChildren for external tools/libraries shared by multiple children"
  echo "  - Use allowed for subsystem-specific dependencies only"
  echo "‚Ä¢ Domain services can only be imported by API/server code"
  echo "‚Ä¢ Domain utils can be imported by anyone"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  exit 1
fi

if [ -n "$WARNINGS" ]; then
  echo ""
  echo "‚ö†Ô∏è  Warnings:"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  printf "%s\n" "$WARNINGS"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
fi

echo "‚úÖ Architecture check passed!"