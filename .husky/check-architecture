#!/bin/sh

# Architecture Boundary Check
# Simple checks: line counts and required files
# Usage: ./check-architecture [path]
# Default path: src

set -e

# Get target path from argument or default to src
TARGET_PATH=${1:-src}

echo "üèóÔ∏è Checking architectural boundaries in $TARGET_PATH..."

# Configuration
COMPLEXITY_THRESHOLD=1000  # Lines before requiring subsystem structure
DOC_THRESHOLD=500          # Lines before requiring README

# Load exceptions from .architecture-ignore file if it exists
load_exceptions() {
  if [ -f ".architecture-ignore" ]; then
    # Read non-comment, non-empty lines from the ignore file
    grep -v '^#' .architecture-ignore 2>/dev/null | grep -v '^$' || echo ""
  else
    # Fallback to hardcoded exceptions
    echo "src/components"
  fi
}

# Check if a path matches any exception pattern
is_exception() {
  local path=$1
  local exceptions=$(load_exceptions)
  
  if [ -z "$exceptions" ]; then
    return 1  # No exceptions defined
  fi
  
  while IFS= read -r pattern; do
    if [ -z "$pattern" ]; then
      continue
    fi
    # Check if path matches the pattern (supports wildcards)
    case "$path" in
      $pattern)
        return 0  # Match found - is an exception
        ;;
    esac
  done <<< "$exceptions"
  
  return 1  # No match - not an exception
}

# Count TypeScript lines in a directory
# Recursive, but stops at subsystem boundaries (folders with interface.ts)
count_ts_lines() {
  local dir=$1
  local total=0
  
  # Count direct files in this directory
  local direct_lines=$(find "$dir" -maxdepth 1 -type f \( -name "*.ts" -o -name "*.tsx" \) -not -name "*.test.*" -not -name "*.spec.*" 2>/dev/null | \
    xargs wc -l 2>/dev/null | \
    tail -1 | \
    awk '{print $1}' || echo 0)
  
  total=$((total + direct_lines))
  
  # For each subdirectory, check if it's a subsystem boundary
  for subdir in "$dir"/*; do
    if [ -d "$subdir" ]; then
      # If subfolder has interface.ts, it's its own subsystem - don't count it
      if [ -f "$subdir/interface.ts" ]; then
        continue  # Skip this subfolder, it's a separate subsystem
      else
        # Not a subsystem, count its lines recursively
        subdir_lines=$(count_ts_lines "$subdir")
        total=$((total + subdir_lines))
      fi
    fi
  done
  
  echo $total
}

ERRORS=""
WARNINGS=""
NEWLINE=$'\n'

# Check all directories for line count
echo "Scanning directories (recursive, stopping at subsystem boundaries)..."
for dir in $(find "$TARGET_PATH" -type d -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*"); do
  # Skip if this directory is in the exception list
  if is_exception "$dir"; then
    continue
  fi
  
  # Skip if this is a child of a subsystem (would be double-counted)
  parent_dir=$(dirname "$dir")
  if [ -f "$parent_dir/interface.ts" ]; then
    if [ "$parent_dir" != "$dir" ]; then
      continue  # Skip children of subsystems
    fi
  fi
  
  lines=$(count_ts_lines "$dir")
  
  if [ "$lines" -gt "$COMPLEXITY_THRESHOLD" ]; then
    # Complex folder - needs full subsystem structure
    missing=""
    [ ! -f "$dir/interface.ts" ] && [ ! -d "$dir/types" ] && missing="$missing interface.ts"
    [ ! -f "$dir/README.md" ] && missing="$missing README.md"
    [ ! -f "$dir/ARCHITECTURE.md" ] && missing="$missing ARCHITECTURE.md"
    [ ! -f "$dir/dependencies.json" ] && missing="$missing dependencies.json"
    
    if [ -n "$missing" ]; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå $dir ($lines lines) missing:$missing"
    fi
    
  elif [ "$lines" -gt "$DOC_THRESHOLD" ]; then
    # Medium complexity - just needs README
    if [ ! -f "$dir/README.md" ]; then
      WARNINGS="${WARNINGS}${NEWLINE}‚ö†Ô∏è  $dir ($lines lines) - missing README.md"
    fi
  fi
done

# Check that subsystems (with interface.ts) have all required files
echo "Checking subsystems for completeness..."
for interface_file in $(find "$TARGET_PATH" -name "interface.ts" -not -path "*/node_modules/*"); do
  dir=$(dirname "$interface_file")
  
  missing=""
  [ ! -f "$dir/README.md" ] && missing="$missing README.md"
  [ ! -f "$dir/ARCHITECTURE.md" ] && missing="$missing ARCHITECTURE.md"
  [ ! -f "$dir/dependencies.json" ] && missing="$missing dependencies.json"
  
  if [ -n "$missing" ]; then
    ERRORS="${ERRORS}${NEWLINE}‚ùå $dir has interface.ts but missing:$missing"
  fi
done

# Check that subsystems are declared in their parent's dependencies.json
echo "Checking subsystem declarations..."
for interface_file in $(find "$TARGET_PATH" -name "interface.ts" -not -path "*/node_modules/*"); do
  subsystem_dir=$(dirname "$interface_file")
  parent_dir=$(dirname "$subsystem_dir")
  
  # Skip if parent is the target path itself (no parent dependencies.json expected)
  if [ "$parent_dir" = "$TARGET_PATH" ] || [ "$parent_dir" = "." ]; then
    continue
  fi
  
  parent_deps_file="$parent_dir/dependencies.json"
  if [ -f "$parent_deps_file" ]; then
    # Get relative path from parent to subsystem
    relative_path=$(echo "$subsystem_dir" | sed "s|$parent_dir/|./|")
    
    # Check if subsystem is declared in parent's dependencies.json
    if ! grep -q "\"$relative_path\"" "$parent_deps_file" 2>/dev/null; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå Subsystem $subsystem_dir not declared in $parent_deps_file"
      ERRORS="${ERRORS}${NEWLINE}   ‚Üí Add \"$relative_path\" to the \"subsystems\" array"
    fi
  fi
done

# Check import boundaries for subsystems with interface.ts
echo "Checking import boundaries..."
for interface_file in $(find "$TARGET_PATH" -name "interface.ts" -not -path "*/node_modules/*"); do
  subsystem_dir=$(dirname "$interface_file")
  subsystem_name=$(basename "$subsystem_dir")
  parent_dir=$(dirname "$subsystem_dir")
  
  # Check external imports (from completely outside the parent system)
  violations=$(find src -name "*.ts" -o -name "*.tsx" | \
    xargs grep -l "from [\"']~/.*/$subsystem_name/" 2>/dev/null | \
    grep -v "^$subsystem_dir/" | \
    grep -v "^$parent_dir/" | \
    xargs grep -H "from [\"']~/.*/$subsystem_name/[^\"']*[\"']" 2>/dev/null | \
    grep -v "/$subsystem_name/interface[\"']" | \
    grep -v "/$subsystem_name/interface\.client[\"']" || true)
  
  if [ -n "$violations" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}‚ùå External imports bypass $subsystem_name/interface.ts:"
    while IFS= read -r violation; do
      if [ -n "$violation" ]; then
        file=$(echo "$violation" | cut -d: -f1)
        import_line=$(echo "$violation" | cut -d: -f2-)
        # Format the import line to be more readable
        import_clean=$(echo "$import_line" | sed 's/^[[:space:]]*//' | sed 's/;$//')
        ERRORS="${ERRORS}${NEWLINE}  üî∏ $file${NEWLINE}     $import_clean"
      fi
    done << EOF
$violations
EOF
  fi
  
  # Check parent imports (from the direct parent system) - should use relative interface
  parent_violations=$(find "$parent_dir" -maxdepth 1 -name "*.ts" -o -name "*.tsx" | \
    xargs grep -H "from [\"']\..*/$subsystem_name/[^\"']*[\"']" 2>/dev/null | \
    grep -v "/$subsystem_name/interface[\"']" | \
    grep -v "/$subsystem_name/interface\.client[\"']" || true)
  
  if [ -n "$parent_violations" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}‚ùå Parent system imports bypass $subsystem_name/interface.ts:"
    while IFS= read -r violation; do
      if [ -n "$violation" ]; then
        file=$(echo "$violation" | cut -d: -f1)
        import_line=$(echo "$violation" | cut -d: -f2-)
        # Format the import line to be more readable
        import_clean=$(echo "$import_line" | sed 's/^[[:space:]]*//' | sed 's/;$//')
        ERRORS="${ERRORS}${NEWLINE}  üî∏ $file${NEWLINE}     $import_clean${NEWLINE}     ‚Üí Should use: from './$subsystem_name/interface'"
      fi
    done << EOF
$parent_violations
EOF
  fi
done

# Report results
if [ -n "$ERRORS" ]; then
  echo ""
  echo "üö® Architecture violations:"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  printf "%s\n" "$ERRORS"
  echo ""
  echo "üìã Requirements:"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  echo "‚Ä¢ Folders over $COMPLEXITY_THRESHOLD lines need:"
  echo "  - interface.ts (or types/ folder)"
  echo "  - dependencies.json"
  echo "  - README.md"
  echo "  - ARCHITECTURE.md"
  echo ""
  echo "‚Ä¢ Subsystems with interface.ts must be declared in their parent's dependencies.json \"subsystems\" array"
  echo "‚Ä¢ Subsystems with interface.ts must be imported ONLY through interface.ts or interface.client.ts"
  echo "‚Ä¢ External imports should use: import { X } from '~/path/to/subsystem/interface' (server) or '~/path/to/subsystem/interface.client' (client)"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  exit 1
fi

if [ -n "$WARNINGS" ]; then
  echo ""
  echo "‚ö†Ô∏è  Warnings:"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  printf "%s\n" "$WARNINGS"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
fi

echo "‚úÖ Architecture check passed!"