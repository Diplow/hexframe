#!/bin/sh

# Architecture Boundary Check
# Enforce architectural boundaries through dependency declarations
#
# CORE PRINCIPLE: Boundaries are complexity inflection points. When this script
# fails, it's a signal to pause and consider if we're adding necessary complexity.
#
# SUBSYSTEM DEFINITION:
# - Identified by dependencies.json file (not interface.ts)
# - All external imports must be explicitly allowed
# - Parent defines child subsystems in "subsystems" array
#
# DOMAIN SPECIAL RULES (src/lib/domains/*):
# - Services: backend-only, exposed via services/index.ts, each service is a subsystem
# - Infrastructure: each folder is a subsystem with dependencies.json
# - Utils: client-safe, exposed via utils/index.ts
# - _objects imports are automatically allowed for domain children
#
# Usage: ./check-architecture [path]
# Default path: src

set -e

# Get target path from argument or default to src
TARGET_PATH=${1:-src}

echo "üèóÔ∏è Checking architectural boundaries in $TARGET_PATH..."

# Configuration
COMPLEXITY_THRESHOLD=1000  # Lines before requiring subsystem structure
DOC_THRESHOLD=500          # Lines before requiring README

# Load exceptions from .architecture-ignore file if it exists
load_exceptions() {
  if [ -f ".architecture-ignore" ]; then
    grep -v '^#' .architecture-ignore 2>/dev/null | grep -v '^$' || echo ""
  else
    echo "src/components"
  fi
}

# Check if a path matches any exception pattern
is_exception() {
  local path=$1
  local exceptions=$(load_exceptions)
  
  if [ -z "$exceptions" ]; then
    return 1
  fi
  
  while IFS= read -r pattern; do
    if [ -z "$pattern" ]; then
      continue
    fi
    case "$path" in
      $pattern)
        return 0
        ;;
    esac
  done <<< "$exceptions"
  
  return 1
}

# Check if path is in a domain
is_domain_path() {
  local path=$1
  case "$path" in
    src/lib/domains/*)
      return 0
      ;;
  esac
  return 1
}

# Get domain type based on path
get_domain_type() {
  local path=$1
  case "$path" in
    */services/*)
      echo "service"
      ;;
    */infrastructure/*)
      echo "infrastructure"
      ;;
    */utils/*)
      echo "utils"
      ;;
    *)
      echo "unknown"
      ;;
  esac
}

# Count TypeScript lines in a directory
# Recursive, but stops at subsystem boundaries (folders with dependencies.json)
count_ts_lines() {
  local dir=$1
  local total=0
  
  # Count direct files in this directory
  local direct_lines=$(find "$dir" -maxdepth 1 -type f \( -name "*.ts" -o -name "*.tsx" \) -not -name "*.test.*" -not -name "*.spec.*" 2>/dev/null | \
    xargs wc -l 2>/dev/null | \
    tail -1 | \
    awk '{print $1}' || echo 0)
  
  total=$((total + direct_lines))
  
  # For each subdirectory, check if it's a subsystem boundary
  for subdir in "$dir"/*; do
    if [ -d "$subdir" ]; then
      # If subfolder has dependencies.json, it's its own subsystem - don't count it
      if [ -f "$subdir/dependencies.json" ]; then
        continue  # Skip this subfolder, it's a separate subsystem
      else
        # Not a subsystem, count its lines recursively
        subdir_lines=$(count_ts_lines "$subdir")
        total=$((total + subdir_lines))
      fi
    fi
  done
  
  echo $total
}

# Load and resolve subsystem dependencies
resolve_allowed_dependencies() {
  local deps_file=$1
  local parent_allowed_children=$2
  
  if [ ! -f "$deps_file" ]; then
    echo ""
    return
  fi
  
  local allowed=""
  local allowed_children=""
  
  # Extract allowed dependencies
  if command -v jq >/dev/null 2>&1; then
    allowed=$(jq -r '.allowed[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    allowed_children=$(jq -r '.allowedChildren[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
  else
    # Fallback to grep/sed parsing - extract array values only
    allowed=$(sed -n '/"allowed":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    allowed_children=$(sed -n '/"allowedChildren":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
  fi
  
  # Combine allowed, allowedChildren, and parent allowedChildren
  local combined=""
  [ -n "$allowed" ] && combined="$allowed"
  [ -n "$allowed_children" ] && combined="$combined|$allowed_children"
  [ -n "$parent_allowed_children" ] && combined="$combined|$parent_allowed_children"
  
  # For domain subsystems, automatically add _objects
  local subsystem_dir=$(dirname "$deps_file")
  if is_domain_path "$subsystem_dir"; then
    combined="$combined|_objects"
  fi
  
  echo "$combined" | sed 's/^|//' | sed 's/|$//'
}

# Find all subsystems (directories with dependencies.json)
find_subsystems() {
  find "$TARGET_PATH" -name "dependencies.json" -not -path "*/node_modules/*" 2>/dev/null | while read deps_file; do
    dirname "$deps_file"
  done
}

# Check for file/folder naming conflicts
check_file_folder_conflicts() {
  local target_path=$1
  local conflicts=""
  
  # Find all TypeScript files
  find "$target_path" -type f \( -name "*.ts" -o -name "*.tsx" \) -not -path "*/node_modules/*" -not -path "*/.git/*" | while read ts_file; do
    # Get the directory containing this file
    file_dir=$(dirname "$ts_file")
    # Get the basename without extension  
    file_basename=$(basename "$ts_file" .ts)
    file_basename=$(basename "$file_basename" .tsx)
    
    # Skip index files as they're the recommended pattern
    if [ "$file_basename" = "index" ]; then
      continue
    fi
    
    # Check if there's a folder with the same name in the same directory
    potential_folder="$file_dir/$file_basename"
    if [ -d "$potential_folder" ]; then
      # Write conflict to temporary file (due to subshell limitations)
      relative_file=$(echo "$ts_file" | sed "s|^$TARGET_PATH/||")
      relative_folder=$(echo "$potential_folder" | sed "s|^$TARGET_PATH/||")
      echo "‚ùå File/folder naming conflict:" >> "/tmp/naming_conflicts_$$"
      echo "  üî∏ File: $relative_file" >> "/tmp/naming_conflicts_$$" 
      echo "  üî∏ Folder: $relative_folder/" >> "/tmp/naming_conflicts_$$"
      echo "     ‚Üí Move file contents to $relative_folder/index.ts" >> "/tmp/naming_conflicts_$$"
      echo "" >> "/tmp/naming_conflicts_$$"
    fi
  done
}

# Validate domain-specific structure
validate_domain_structure() {
  local domain_path=$1
  
  # Check if services are properly structured
  if [ -d "$domain_path/services" ]; then
    # Each service file should have its own dependencies.json
    find "$domain_path/services" -maxdepth 1 -name "*.ts" -not -name "index.ts" | while read service_file; do
      service_name=$(basename "$service_file" .ts)
      if [ ! -f "$domain_path/services/dependencies.json" ]; then
        ERRORS="${ERRORS}${NEWLINE}‚ùå Service $service_file needs its own dependencies.json in services/"
      fi
    done
    
    # Services must be exposed in services/index.ts
    if [ ! -f "$domain_path/services/index.ts" ]; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå $domain_path/services missing index.ts to expose services"
    fi
  fi
  
  # Check infrastructure structure
  find "$domain_path" -mindepth 3 -path "*/infrastructure/*" -type d | while read infra_dir; do
    if [ ! -f "$infra_dir/dependencies.json" ]; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå Infrastructure $infra_dir needs dependencies.json"
    fi
  done
  
  # Check utils structure
  if [ -d "$domain_path/utils" ]; then
    if [ ! -f "$domain_path/utils/index.ts" ]; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå $domain_path/utils missing index.ts to expose utilities"
    fi
  fi
}

ERRORS=""
WARNINGS=""
NEWLINE=$'\n'

# Check all directories for complexity requirements
echo "Scanning directories for complexity requirements..."
for dir in $(find "$TARGET_PATH" -type d -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*"); do
  if is_exception "$dir"; then
    continue
  fi
  
  # Skip if this is a child of a subsystem (would be double-counted)
  parent_dir=$(dirname "$dir")
  if [ -f "$parent_dir/dependencies.json" ]; then
    if [ "$parent_dir" != "$dir" ]; then
      continue
    fi
  fi
  
  lines=$(count_ts_lines "$dir")
  
  if [ "$lines" -gt "$COMPLEXITY_THRESHOLD" ]; then
    # Complex folder - needs full subsystem structure
    missing=""
    [ ! -f "$dir/dependencies.json" ] && missing="$missing dependencies.json"
    [ ! -f "$dir/README.md" ] && missing="$missing README.md"
    [ ! -f "$dir/ARCHITECTURE.md" ] && missing="$missing ARCHITECTURE.md"
    
    if [ -n "$missing" ]; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå $dir ($lines lines) missing:$missing"
    fi
    
  elif [ "$lines" -gt "$DOC_THRESHOLD" ]; then
    # Medium complexity - just needs README
    if [ ! -f "$dir/README.md" ]; then
      WARNINGS="${WARNINGS}${NEWLINE}‚ö†Ô∏è  $dir ($lines lines) - missing README.md"
    fi
  fi
done

# Check that subsystems have all required files
echo "Checking subsystems for completeness..."
find_subsystems | while read subsystem_dir; do
  missing=""
  [ ! -f "$subsystem_dir/README.md" ] && missing="$missing README.md"
  [ ! -f "$subsystem_dir/ARCHITECTURE.md" ] && missing="$missing ARCHITECTURE.md"
  
  if [ -n "$missing" ]; then
    ERRORS="${ERRORS}${NEWLINE}‚ùå Subsystem $subsystem_dir missing:$missing"
  fi
done

# Check that subsystems are declared in their parent's dependencies.json
echo "Checking subsystem declarations..."
find_subsystems | while read subsystem_dir; do
  parent_dir=$(dirname "$subsystem_dir")
  
  # Skip if parent is the target path itself
  if [ "$parent_dir" = "$TARGET_PATH" ] || [ "$parent_dir" = "." ]; then
    continue
  fi
  
  parent_deps_file="$parent_dir/dependencies.json"
  if [ -f "$parent_deps_file" ]; then
    relative_path=$(echo "$subsystem_dir" | sed "s|$parent_dir/|./|")
    
    if ! grep -q "\"$relative_path\"" "$parent_deps_file" 2>/dev/null; then
      ERRORS="${ERRORS}${NEWLINE}‚ùå Subsystem $subsystem_dir not declared in $parent_deps_file"
      ERRORS="${ERRORS}${NEWLINE}   ‚Üí Add \"$relative_path\" to the \"subsystems\" array"
    fi
  fi
done

# Check import boundaries for subsystems
echo "Checking import boundaries..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  parent_dir=$(dirname "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  
  # Get parent's allowedChildren
  parent_deps_file="$parent_dir/dependencies.json"
  parent_allowed_children=""
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # Check external imports (from completely outside the parent system)
  violations=$(find src -name "*.ts" -o -name "*.tsx" | \
    xargs grep -l "from [\"']~/.*/$subsystem_name/" 2>/dev/null | \
    grep -v "^$subsystem_dir/" | \
    grep -v "^$parent_dir/" | \
    xargs grep -H "from [\"']~/.*/$subsystem_name/[^\"']*[\"']" 2>/dev/null | \
    grep -v "/$subsystem_name[\"']" | \
    grep -v "/$subsystem_name/index[\"']" || true)
  
  if [ -n "$violations" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}‚ùå External imports bypass $subsystem_name/index:"
    while IFS= read -r violation; do
      if [ -n "$violation" ]; then
        file=$(echo "$violation" | cut -d: -f1)
        import_line=$(echo "$violation" | cut -d: -f2-)
        import_clean=$(echo "$import_line" | sed 's/^[[:space:]]*//' | sed 's/;$//')
        ERRORS="${ERRORS}${NEWLINE}  üî∏ $file${NEWLINE}     $import_clean"
      fi
    done << EOF
$violations
EOF
  fi
  
  # Check parent imports - should use relative index
  parent_violations=$(find "$parent_dir" -maxdepth 1 -name "*.ts" -o -name "*.tsx" | \
    xargs grep -H "from [\"']\.\.*/$subsystem_name/[^\"']*[\"']" 2>/dev/null | \
    grep -v "/$subsystem_name[\"']" | \
    grep -v "/$subsystem_name/index[\"']" || true)
  
  if [ -n "$parent_violations" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}‚ùå Parent system imports bypass $subsystem_name/index:"
    while IFS= read -r violation; do
      if [ -n "$violation" ]; then
        file=$(echo "$violation" | cut -d: -f1)
        import_line=$(echo "$violation" | cut -d: -f2-)
        import_clean=$(echo "$import_line" | sed 's/^[[:space:]]*//' | sed 's/;$//')
        ERRORS="${ERRORS}${NEWLINE}  üî∏ $file${NEWLINE}     $import_clean${NEWLINE}     ‚Üí Should use: from './$subsystem_name'"
      fi
    done << EOF
$parent_violations
EOF
  fi
done

# Check outbound dependencies for subsystems
echo "Checking outbound dependencies..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  parent_dir=$(dirname "$subsystem_dir")
  
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Get parent's allowedChildren
  parent_allowed_children=""
  parent_deps_file="$parent_dir/dependencies.json"
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # Resolve all allowed dependencies
  allowed_deps=$(resolve_allowed_dependencies "$deps_file" "$parent_allowed_children")
  
  # Find all TypeScript files in the subsystem
  for ts_file in $(find "$subsystem_dir" -name "*.ts" -o -name "*.tsx" | grep -v "__tests__" | grep -v ".test.ts" | grep -v ".spec.ts"); do
    # Find imports that go outside the subsystem
    outbound_imports=$(grep -n "from [\"']\.\./\|from [\"']~/" "$ts_file" 2>/dev/null || true)
    
    if [ -n "$outbound_imports" ]; then
      # Process imports without subshell to preserve ERRORS variable
      echo "$outbound_imports" | while IFS= read -r import_line; do
        if [ -n "$import_line" ]; then
          line_num=$(echo "$import_line" | cut -d: -f1)
          import_path=$(echo "$import_line" | sed "s/.*from [\"']\([^\"']*\)[\"'].*/\1/")
          
          # Check if this import is allowed
          is_allowed=false
          
          if [ -n "$allowed_deps" ]; then
            # Normalize the import path for comparison
            normalized_path="$import_path"
            case "$import_path" in
              "../"*) 
                normalized_path="$import_path"
                ;;
              "~/"*) 
                # Convert absolute paths to relative from domain perspective
                domain_relative=$(echo "$import_path" | sed "s|~/lib/domains/[^/]*/||")
                if [ "$domain_relative" != "$import_path" ]; then
                  normalized_path="../$domain_relative"
                fi
                ;;
            esac
            
            # Check if normalized path matches any allowed dependency
            IFS='|' read -ra DEPS <<< "$allowed_deps"
            for allowed_dep in "${DEPS[@]}"; do
              case "$normalized_path" in
                "$allowed_dep"*) 
                  is_allowed=true
                  break
                  ;;
              esac
            done
          fi
          
          if [ "$is_allowed" = false ]; then
            # Write to temporary error file instead of variable due to subshell
            relative_file=$(echo "$ts_file" | sed "s|^$subsystem_dir/||")
            echo "‚ùå Undeclared outbound dependency in $subsystem_name:" >> "/tmp/arch_errors_$$"
            echo "  üî∏ $relative_file:$line_num" >> "/tmp/arch_errors_$$"
            echo "     import from '$import_path'" >> "/tmp/arch_errors_$$"
            echo "     ‚Üí Add '$normalized_path' to dependencies.json 'allowed' array" >> "/tmp/arch_errors_$$"
            echo "" >> "/tmp/arch_errors_$$"
          fi
        fi
      done
    fi
  done
done

# Read temporary error file and add to ERRORS
if [ -f "/tmp/arch_errors_$$" ]; then
  temp_errors=$(cat "/tmp/arch_errors_$$")
  if [ -n "$temp_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$temp_errors"
  fi
  rm -f "/tmp/arch_errors_$$"
fi

# Check hierarchical dependency violations
echo "Checking hierarchical dependencies..."

# Helper function to count path depth (number of ../ segments)
count_path_depth() {
  local path="$1"
  echo "$path" | grep -o "\.\.\/" | wc -l
}

# Helper function to check if a path goes beyond direct children
is_hierarchical_violation() {
  local import_path="$1"
  local subsystem_dir="$2"
  
  # Skip non-relative imports
  case "$import_path" in
    "../"*)
      # Count the number of ../ segments
      depth=$(count_path_depth "$import_path")
      
      # More than 1 ../ means going beyond direct parent/sibling
      # More than 2 levels deep in relative imports suggests accessing grandchildren
      if [ "$depth" -gt 2 ]; then
        return 0  # Is a violation
      fi
      
      # Check if the path goes through multiple subsystem boundaries
      # Pattern: ../SubsystemA/SubsystemB/something (accessing grandchild)
      if echo "$import_path" | grep -q "\.\./[^/]*/[^/]*/"; then
        return 0  # Is a violation
      fi
      ;;
  esac
  
  return 1  # Not a violation
}

find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  
  # Skip if no dependencies.json
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Find all TypeScript files in the subsystem
  for ts_file in $(find "$subsystem_dir" -name "*.ts" -o -name "*.tsx" | grep -v "__tests__" | grep -v ".test.ts" | grep -v ".spec.ts"); do
    # Find imports that go outside the subsystem
    outbound_imports=$(grep -n "from [\"']\.\./\|from [\"']~/" "$ts_file" 2>/dev/null || true)
    
    if [ -n "$outbound_imports" ]; then
      echo "$outbound_imports" | while IFS= read -r import_line; do
        if [ -n "$import_line" ]; then
          line_num=$(echo "$import_line" | cut -d: -f1)
          import_path=$(echo "$import_line" | sed "s/.*from [\"']\([^\"']*\)[\"'].*/\1/")
          
          # Check if this is a hierarchical violation
          if is_hierarchical_violation "$import_path" "$subsystem_dir"; then
            relative_file=$(echo "$ts_file" | sed "s|^$subsystem_dir/||")
            echo "‚ö†Ô∏è Hierarchical dependency violation in $subsystem_name:" >> "/tmp/hierarchical_errors_$$"
            echo "  üî∏ $relative_file:$line_num" >> "/tmp/hierarchical_errors_$$"
            echo "     import from '$import_path'" >> "/tmp/hierarchical_errors_$$"
            echo "     ‚Üí This imports from a grandchild subsystem. Create reexports in intermediate subsystems." >> "/tmp/hierarchical_errors_$$"
            echo "" >> "/tmp/hierarchical_errors_$$"
          fi
        fi
      done
    fi
  done
done

# Read hierarchical error file and add to ERRORS
if [ -f "/tmp/hierarchical_errors_$$" ]; then
  hierarchical_errors=$(cat "/tmp/hierarchical_errors_$$")
  if [ -n "$hierarchical_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$hierarchical_errors"
  fi
  rm -f "/tmp/hierarchical_errors_$$"
fi

# Check for file/folder naming conflicts
echo "Checking for file/folder naming conflicts..."
check_file_folder_conflicts "$TARGET_PATH"

# Read naming conflicts file and add to ERRORS
if [ -f "/tmp/naming_conflicts_$$" ]; then
  naming_conflicts=$(cat "/tmp/naming_conflicts_$$")
  if [ -n "$naming_conflicts" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$naming_conflicts"
  fi
  rm -f "/tmp/naming_conflicts_$$"
fi

# Validate domain-specific structure
echo "Checking domain structure..."
for domain_dir in $(find "$TARGET_PATH/lib/domains" -mindepth 1 -maxdepth 1 -type d 2>/dev/null); do
  validate_domain_structure "$domain_dir"
done

# Check domain import restrictions
echo "Checking domain import restrictions..."
find "$TARGET_PATH/lib/domains" -path "*/services/*.ts" -not -name "index.ts" 2>/dev/null | while read service_file; do
  # Find files that import this service (should only be API/server files)
  service_imports=$(find src -name "*.ts" -o -name "*.tsx" | \
    xargs grep -l "from.*$(echo "$service_file" | sed 's/.*domains/domains/' | sed 's/\.ts$//')" 2>/dev/null | \
    grep -v "^src/app/api/" | \
    grep -v "^src/server/" | \
    grep -v "$service_file" || true)
  
  if [ -n "$service_imports" ]; then
    service_name=$(basename "$service_file" .ts)
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}‚ùå Service $service_name imported by non-API files:"
    while IFS= read -r importing_file; do
      if [ -n "$importing_file" ]; then
        ERRORS="${ERRORS}${NEWLINE}  üî∏ $importing_file"
        ERRORS="${ERRORS}${NEWLINE}     ‚Üí Services can only be imported by API/server code"
      fi
    done << EOF
$service_imports
EOF
  fi
done

# Report results
if [ -n "$ERRORS" ]; then
  echo ""
  echo "üö® Architecture violations:"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  printf "%s\n" "$ERRORS"
  echo ""
  echo "üìã Requirements:"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  echo "‚Ä¢ Folders over $COMPLEXITY_THRESHOLD lines need:"
  echo "  - dependencies.json"
  echo "  - README.md"
  echo "  - ARCHITECTURE.md"
  echo ""
  echo "‚Ä¢ File/folder naming conflicts:"
  echo "  - If both types.ts and types/ exist, move types.ts content to types/index.ts"
  echo "  - This prevents ambiguous imports and follows the index pattern"
  echo ""
  echo "‚Ä¢ Subsystems with dependencies.json must be declared in their parent's \"subsystems\" array"
  echo "‚Ä¢ Subsystems must be imported through their index.ts (renamed from interface.ts)"
  echo "‚Ä¢ External imports should use: import { X } from '~/path/to/subsystem' (automatically uses index.ts)"
  echo "‚Ä¢ Domain services can only be imported by API/server code"
  echo "‚Ä¢ Domain utils can be imported by anyone"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  exit 1
fi

if [ -n "$WARNINGS" ]; then
  echo ""
  echo "‚ö†Ô∏è  Warnings:"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  printf "%s\n" "$WARNINGS"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
fi

echo "‚úÖ Architecture check passed!"