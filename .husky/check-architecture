#!/bin/sh
#
# Architecture Boundary Check - Fast Python Implementation with Bash Fallback
# 
# Usage:
#   pnpm check:architecture [path]     # Recommended: uses pnpm environment
#   bash .husky/check-architecture     # Direct execution (may fail if tools not in PATH)
#
# CORE PRINCIPLE: Boundaries are complexity inflection points. When this script
# fails, it's a signal to pause and consider if we're adding necessary complexity.
#
# SUBSYSTEM DEFINITION:
# - Identified by dependencies.json file (not interface.ts)
# - All external imports must be explicitly allowed
# - Parent defines child subsystems in "subsystems" array
#
# DOMAIN SPECIAL RULES (src/lib/domains/*):
# - Services: backend-only, exposed via services/index.ts, each service is a subsystem
# - Infrastructure: each folder is a subsystem with dependencies.json
# - Utils: client-safe, exposed via utils/index.ts
# - _objects imports are automatically allowed for domain children
#
# PATH HIERARCHY LOGIC:
# - If ~/lib/utils is allowed, automatically allows ~/lib/utils/* 
# - Exception: Subsystems in allowed paths still need explicit permission
# - Example: ~/app/map allows ~/app/map/types but NOT ~/app/map/Cache (subsystem)
#
# Default path: src

set -e

# Try Python implementation first (much faster), fallback to bash
if command -v python3 >/dev/null 2>&1 && [ -f "scripts/check-architecture.py" ]; then
    python3 scripts/check-architecture.py "$@"
    exit $?
fi

echo "⚠️  Python3 not available or scripts/check-architecture.py missing, using bash fallback..."
echo "   (This will be slower - consider installing Python3 for better performance)"
echo ""

# Get target path from argument or default to src
TARGET_PATH=${1:-src}

echo "🏗️ Checking architectural boundaries in $TARGET_PATH..."

# Configuration
COMPLEXITY_THRESHOLD=1000  # Lines before requiring subsystem structure
DOC_THRESHOLD=500          # Lines before requiring README

# Load exceptions from .architecture-ignore file if it exists
load_exceptions() {
  if [ -f ".architecture-ignore" ]; then
    grep -v '^#' .architecture-ignore 2>/dev/null | grep -v '^$' || echo ""
  else
    echo "src/components"
  fi
}

# Check if a path matches any exception pattern
is_exception() {
  local path=$1
  local exceptions=$(load_exceptions)
  
  if [ -z "$exceptions" ]; then
    return 1
  fi
  
  while IFS= read -r pattern; do
    if [ -z "$pattern" ]; then
      continue
    fi
    case "$path" in
      $pattern)
        return 0
        ;;
    esac
  done <<< "$exceptions"
  
  return 1
}

# Check if path is in a domain
is_domain_path() {
  local path=$1
  case "$path" in
    src/lib/domains/*)
      return 0
      ;;
  esac
  return 1
}

# Get domain type based on path
get_domain_type() {
  local path=$1
  case "$path" in
    */services/*)
      echo "service"
      ;;
    */infrastructure/*)
      echo "infrastructure"
      ;;
    */utils/*)
      echo "utils"
      ;;
    *)
      echo "unknown"
      ;;
  esac
}

# Count TypeScript lines in a directory
# Recursive, but stops at subsystem boundaries (folders with dependencies.json)
count_ts_lines() {
  local dir=$1
  local total=0
  
  # Count direct files in this directory
  local direct_lines=$(find "$dir" -maxdepth 1 -type f \( -name "*.ts" -o -name "*.tsx" \) -not -name "*.test.*" -not -name "*.spec.*" 2>/dev/null | \
    xargs wc -l 2>/dev/null | \
    tail -1 | \
    awk '{print $1}' || echo 0)
  
  total=$((total + direct_lines))
  
  # For each subdirectory, check if it's a subsystem boundary
  for subdir in "$dir"/*; do
    if [ -d "$subdir" ]; then
      # If subfolder has dependencies.json, it's its own subsystem - don't count it
      if [ -f "$subdir/dependencies.json" ]; then
        continue  # Skip this subfolder, it's a separate subsystem
      else
        # Not a subsystem, count its lines recursively
        subdir_lines=$(count_ts_lines "$subdir")
        total=$((total + subdir_lines))
      fi
    fi
  done
  
  echo $total
}

# Check if a path is allowed through hierarchy or explicit declaration
is_path_allowed() {
  local import_path=$1
  local allowed_deps=$2
  local subsystem_dir=$3
  
  # Convert subsystem_dir to absolute path format for comparison
  local subsystem_abs_path=""
  if [[ "$subsystem_dir" == src/* ]]; then
    subsystem_abs_path="~/${subsystem_dir#src/}"
  else
    subsystem_abs_path="$subsystem_dir"
  fi
  
  # Allow internal imports within the same subsystem
  case "$import_path" in
    "$subsystem_abs_path"*)
      return 0  # Internal import
      ;;
  esac
  
  if [ -z "$allowed_deps" ]; then
    return 1
  fi
  
  # Check direct matches first
  IFS='|' read -ra DEPS <<< "$allowed_deps"
  for allowed_dep in "${DEPS[@]}"; do
    case "$import_path" in
      "$allowed_dep")
        return 0  # Exact match
        ;;
      "$allowed_dep"*)
        # Check if it's a hierarchical match
        # If allowed path is ~/lib/utils, allow ~/lib/utils/something
        # But NOT if the child is a subsystem
        local child_path=$(echo "$import_path" | sed "s|^$allowed_dep/||" | sed "s|^$allowed_dep||")
        
        # If there's no child path, it's an exact match
        if [ -z "$child_path" ] || [ "$child_path" = "$import_path" ]; then
          return 0
        fi
        
        # Check if the child path contains a subsystem
        # Look for dependencies.json in the child path
        local potential_subsystem_path=""
        if [[ "$allowed_dep" == ~/* ]]; then
          # Convert ~/path to src/path for file system checking
          potential_subsystem_path="src/${allowed_dep#\~/}/$child_path"
        else
          potential_subsystem_path="$allowed_dep/$child_path"
        fi
        
        # If child is a subsystem (has dependencies.json), require explicit permission
        if [ -f "$potential_subsystem_path/dependencies.json" ]; then
          return 1  # Child is subsystem, needs explicit permission
        fi
        
        # Otherwise, hierarchy allows it
        return 0
        ;;
    esac
  done
  
  return 1  # Not allowed
}

# Resolve full inheritance chain of allowedChildren from all ancestors
resolve_full_inheritance_chain() {
  local subsystem_dir=$1
  local all_inherited=""
  
  # Walk up the directory tree to find all parents with dependencies.json
  local current_dir="$subsystem_dir"
  
  while true; do
    local parent_dir=$(dirname "$current_dir")
    
    # Stop if we've reached src or root (don't stop at TARGET_PATH)
    if [ "$parent_dir" = "src" ] || [ "$parent_dir" = "/" ] || [ "$parent_dir" = "." ] || [ "$parent_dir" = "$current_dir" ]; then
      break
    fi
    
    local parent_deps_file="$parent_dir/dependencies.json"
    if [ -f "$parent_deps_file" ]; then
      # Extract allowedChildren from this parent
      local parent_allowed_children=""
      if command -v jq >/dev/null 2>&1; then
        parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
      else
        parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
      fi
      
      # Add to inherited chain
      if [ -n "$parent_allowed_children" ]; then
        if [ -n "$all_inherited" ]; then
          all_inherited="$all_inherited|$parent_allowed_children"
        else
          all_inherited="$parent_allowed_children"
        fi
      fi
    fi
    
    current_dir="$parent_dir"
  done
  
  echo "$all_inherited"
}

# Load and resolve subsystem dependencies
resolve_allowed_dependencies() {
  local deps_file=$1
  local parent_allowed_children=$2
  
  if [ ! -f "$deps_file" ]; then
    echo ""
    return
  fi
  
  local allowed=""
  local allowed_children=""
  
  # Extract allowed dependencies
  if command -v jq >/dev/null 2>&1; then
    allowed=$(jq -r '.allowed[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    allowed_children=$(jq -r '.allowedChildren[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
  else
    # Fallback to grep/sed parsing - extract array values only
    allowed=$(sed -n '/"allowed":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    allowed_children=$(sed -n '/"allowedChildren":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
  fi
  
  # Combine allowed, allowedChildren, and parent allowedChildren
  local combined=""
  [ -n "$allowed" ] && combined="$allowed"
  [ -n "$allowed_children" ] && combined="$combined|$allowed_children"
  [ -n "$parent_allowed_children" ] && combined="$combined|$parent_allowed_children"
  
  # For domain subsystems, automatically add _objects
  local subsystem_dir=$(dirname "$deps_file")
  if is_domain_path "$subsystem_dir"; then
    combined="$combined|_objects"
  fi
  
  echo "$combined" | sed 's/^|//' | sed 's/|$//'
}

# Find all subsystems (directories with dependencies.json)
find_subsystems() {
  find "$TARGET_PATH" -name "dependencies.json" -not -path "*/node_modules/*" 2>/dev/null | while read deps_file; do
    dirname "$deps_file"
  done
}

# Check for file/folder naming conflicts
check_file_folder_conflicts() {
  local target_path=$1
  local conflicts=""
  
  # Find all TypeScript files
  find "$target_path" -type f \( -name "*.ts" -o -name "*.tsx" \) -not -path "*/node_modules/*" -not -path "*/.git/*" | while read ts_file; do
    # Get the directory containing this file
    file_dir=$(dirname "$ts_file")
    # Get the basename without extension  
    file_basename=$(basename "$ts_file" .ts)
    file_basename=$(basename "$file_basename" .tsx)
    
    # Skip index files as they're the recommended pattern
    if [ "$file_basename" = "index" ]; then
      continue
    fi
    
    # Check if there's a folder with the same name in the same directory
    potential_folder="$file_dir/$file_basename"
    if [ -d "$potential_folder" ]; then
      # Write conflict to temporary file (due to subshell limitations)
      relative_file=$(echo "$ts_file" | sed "s|^$TARGET_PATH/||")
      relative_folder=$(echo "$potential_folder" | sed "s|^$TARGET_PATH/||")
      echo "❌ File/folder naming conflict:" >> "/tmp/naming_conflicts_$$"
      echo "  🔸 File: $relative_file" >> "/tmp/naming_conflicts_$$" 
      echo "  🔸 Folder: $relative_folder/" >> "/tmp/naming_conflicts_$$"
      echo "     → Move file contents to $relative_folder/index.ts" >> "/tmp/naming_conflicts_$$"
      echo "" >> "/tmp/naming_conflicts_$$"
    fi
  done
}

# Validate domain-specific structure
validate_domain_structure() {
  local domain_path=$1
  
  # Check if services are properly structured
  if [ -d "$domain_path/services" ]; then
    # Each service file should have its own dependencies.json
    find "$domain_path/services" -maxdepth 1 -name "*.ts" -not -name "index.ts" | while read service_file; do
      service_name=$(basename "$service_file" .ts)
      if [ ! -f "$domain_path/services/dependencies.json" ]; then
        ERRORS="${ERRORS}${NEWLINE}❌ Service $service_file needs its own dependencies.json in services/"
      fi
    done
    
    # Services must be exposed in services/index.ts
    if [ ! -f "$domain_path/services/index.ts" ]; then
      ERRORS="${ERRORS}${NEWLINE}❌ $domain_path/services missing index.ts to expose services"
    fi
  fi
  
  # Check infrastructure structure
  find "$domain_path" -mindepth 3 -path "*/infrastructure/*" -type d | while read infra_dir; do
    if [ ! -f "$infra_dir/dependencies.json" ]; then
      ERRORS="${ERRORS}${NEWLINE}❌ Infrastructure $infra_dir needs dependencies.json"
    fi
  done
  
  # Check utils structure
  if [ -d "$domain_path/utils" ]; then
    if [ ! -f "$domain_path/utils/index.ts" ]; then
      ERRORS="${ERRORS}${NEWLINE}❌ $domain_path/utils missing index.ts to expose utilities"
    fi
  fi
}

ERRORS=""
WARNINGS=""
NEWLINE=$'\n'

# Check all directories for complexity requirements
echo "Scanning directories for complexity requirements..."
for dir in $(find "$TARGET_PATH" -type d -not -path "*/node_modules/*" -not -path "*/.git/*" -not -path "*/dist/*" -not -path "*/build/*"); do
  if is_exception "$dir"; then
    continue
  fi
  
  # Skip if this is a child of a subsystem (would be double-counted)
  parent_dir=$(dirname "$dir")
  if [ -f "$parent_dir/dependencies.json" ]; then
    if [ "$parent_dir" != "$dir" ]; then
      continue
    fi
  fi
  
  lines=$(count_ts_lines "$dir")
  
  if [ "$lines" -gt "$COMPLEXITY_THRESHOLD" ]; then
    # Complex folder - needs full subsystem structure
    missing=""
    [ ! -f "$dir/dependencies.json" ] && missing="$missing dependencies.json"
    [ ! -f "$dir/README.md" ] && missing="$missing README.md"
    [ ! -f "$dir/ARCHITECTURE.md" ] && missing="$missing ARCHITECTURE.md"
    
    if [ -n "$missing" ]; then
      ERRORS="${ERRORS}${NEWLINE}❌ $dir ($lines lines) missing:$missing"
    fi
    
  elif [ "$lines" -gt "$DOC_THRESHOLD" ]; then
    # Medium complexity - just needs README
    if [ ! -f "$dir/README.md" ]; then
      WARNINGS="${WARNINGS}${NEWLINE}⚠️  $dir ($lines lines) - missing README.md"
    fi
  fi
done

# Check that subsystems have all required files
echo "Checking subsystems for completeness..."
find_subsystems | while read subsystem_dir; do
  missing=""
  [ ! -f "$subsystem_dir/README.md" ] && missing="$missing README.md"
  [ ! -f "$subsystem_dir/ARCHITECTURE.md" ] && missing="$missing ARCHITECTURE.md"
  
  if [ -n "$missing" ]; then
    ERRORS="${ERRORS}${NEWLINE}❌ Subsystem $subsystem_dir missing:$missing"
  fi
done

# Check that subsystems are declared in their parent's dependencies.json
echo "Checking subsystem declarations..."
find_subsystems | while read subsystem_dir; do
  parent_dir=$(dirname "$subsystem_dir")
  
  # Skip if parent is the target path itself
  if [ "$parent_dir" = "$TARGET_PATH" ] || [ "$parent_dir" = "." ]; then
    continue
  fi
  
  parent_deps_file="$parent_dir/dependencies.json"
  if [ -f "$parent_deps_file" ]; then
    relative_path=$(echo "$subsystem_dir" | sed "s|$parent_dir/|./|")
    
    if ! grep -q "\"$relative_path\"" "$parent_deps_file" 2>/dev/null; then
      ERRORS="${ERRORS}${NEWLINE}❌ Subsystem $subsystem_dir not declared in $parent_deps_file"
      ERRORS="${ERRORS}${NEWLINE}   → Add \"$relative_path\" to the \"subsystems\" array"
    fi
  fi
done

# Check import boundaries for subsystems
echo "Checking import boundaries..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  parent_dir=$(dirname "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  
  # Get parent's allowedChildren
  parent_deps_file="$parent_dir/dependencies.json"
  parent_allowed_children=""
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # Check external imports (from completely outside the parent system)
  violations=$(find src -name "*.ts" -o -name "*.tsx" | \
    xargs grep -l "from [\"']~/.*/$subsystem_name/" 2>/dev/null | \
    grep -v "^$subsystem_dir/" | \
    grep -v "^$parent_dir/" | \
    xargs grep -H "from [\"']~/.*/$subsystem_name/[^\"']*[\"']" 2>/dev/null | \
    grep -v "/$subsystem_name[\"']" | \
    grep -v "/$subsystem_name/index[\"']" || true)
  
  if [ -n "$violations" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}❌ External imports bypass $subsystem_name/index:"
    while IFS= read -r violation; do
      if [ -n "$violation" ]; then
        file=$(echo "$violation" | cut -d: -f1)
        import_line=$(echo "$violation" | cut -d: -f2-)
        import_clean=$(echo "$import_line" | sed 's/^[[:space:]]*//' | sed 's/;$//')
        ERRORS="${ERRORS}${NEWLINE}  🔸 $file${NEWLINE}     $import_clean"
      fi
    done << EOF
$violations
EOF
  fi
  
  # Check parent imports - should use relative index
  parent_violations=$(find "$parent_dir" -maxdepth 1 -name "*.ts" -o -name "*.tsx" | \
    xargs grep -H "from [\"']\.\.*/$subsystem_name/[^\"']*[\"']" 2>/dev/null | \
    grep -v "/$subsystem_name[\"']" | \
    grep -v "/$subsystem_name/index[\"']" || true)
  
  if [ -n "$parent_violations" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}❌ Parent system imports bypass $subsystem_name/index:"
    while IFS= read -r violation; do
      if [ -n "$violation" ]; then
        file=$(echo "$violation" | cut -d: -f1)
        import_line=$(echo "$violation" | cut -d: -f2-)
        import_clean=$(echo "$import_line" | sed 's/^[[:space:]]*//' | sed 's/;$//')
        ERRORS="${ERRORS}${NEWLINE}  🔸 $file${NEWLINE}     $import_clean${NEWLINE}     → Should use: from './$subsystem_name'"
      fi
    done << EOF
$parent_violations
EOF
  fi
done

# Check that dependencies.json files use absolute paths
echo "Checking dependencies.json path format..."
find_subsystems | while read subsystem_dir; do
  deps_file="$subsystem_dir/dependencies.json"
  
  if [ -f "$deps_file" ]; then
    # Check for relative paths in allowed array
    relative_paths=$(grep -n '"\.\./' "$deps_file" 2>/dev/null | grep -v '"subsystems"' || true)
    relative_current_paths=$(grep -n '"\\./' "$deps_file" 2>/dev/null | grep -v '"subsystems"' || true)
    
    if [ -n "$relative_paths" ]; then
      while IFS= read -r line; do
        if [ -n "$line" ]; then
          line_num=$(echo "$line" | cut -d: -f1)
          path_content=$(echo "$line" | cut -d: -f2-)
          ERRORS="${ERRORS}${NEWLINE}❌ Relative path in $deps_file:$line_num"
          ERRORS="${ERRORS}${NEWLINE}  $path_content"
          ERRORS="${ERRORS}${NEWLINE}   → Use absolute paths with ~/ prefix instead"
        fi
      done << EOF
$relative_paths
EOF
    fi
    
    if [ -n "$relative_current_paths" ]; then
      while IFS= read -r line; do
        if [ -n "$line" ]; then
          # Skip subsystems array - those should remain relative
          if echo "$line" | grep -q '"subsystems"' || echo "$line" | grep -q 'subsystem'; then
            continue
          fi
          
          line_num=$(echo "$line" | cut -d: -f1)
          path_content=$(echo "$line" | cut -d: -f2-)
          ERRORS="${ERRORS}${NEWLINE}❌ Relative current dir path in $deps_file:$line_num"
          ERRORS="${ERRORS}${NEWLINE}  $path_content"
          ERRORS="${ERRORS}${NEWLINE}   → Use absolute paths with ~/ prefix instead (except for subsystems)"
        fi
      done << EOF
$relative_current_paths
EOF
    fi
  fi
done

# Check for redundant dependencies (child redeclaring parent allowedChildren)
echo "Checking for redundant dependency declarations..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  parent_dir=$(dirname "$subsystem_dir")
  
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Get parent's allowedChildren
  parent_deps_file="$parent_dir/dependencies.json"
  parent_allowed_children=""
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # If parent has allowedChildren, check child's allowed array for conflicts
  if [ -n "$parent_allowed_children" ]; then
    # Get child's allowed dependencies
    child_allowed=""
    if command -v jq >/dev/null 2>&1; then
      child_allowed=$(jq -r '.allowed[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      child_allowed=$(sed -n '/"allowed":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
    
    # Check each child allowed dependency against parent allowedChildren
    if [ -n "$child_allowed" ]; then
      IFS='|' read -ra CHILD_DEPS <<< "$child_allowed"
      
      for child_dep in "${CHILD_DEPS[@]}"; do
        # Use exact match with pipe delimiters as word boundaries
        if echo "|$parent_allowed_children|" | grep -q "|$child_dep|"; then
          echo "❌ Redundant dependency in $subsystem_name:" >> "/tmp/redundant_deps_$$"
          echo "  🔸 '$child_dep' is already provided by parent allowedChildren" >> "/tmp/redundant_deps_$$"
          echo "     → Remove from $deps_file 'allowed' array" >> "/tmp/redundant_deps_$$"
          echo "     → Parent allowedChildren automatically cascades to children" >> "/tmp/redundant_deps_$$"
          echo "" >> "/tmp/redundant_deps_$$"
        fi
      done
    fi
  fi
done

# Check for redundant allowedChildren (child redeclaring parent allowedChildren)
echo "Checking for redundant allowedChildren declarations..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  parent_dir=$(dirname "$subsystem_dir")
  
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Get parent's allowedChildren
  parent_deps_file="$parent_dir/dependencies.json"
  parent_allowed_children=""
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # If parent has allowedChildren, check child's allowedChildren array for conflicts
  if [ -n "$parent_allowed_children" ]; then
    # Get child's allowedChildren dependencies
    child_allowed_children=""
    if command -v jq >/dev/null 2>&1; then
      child_allowed_children=$(jq -r '.allowedChildren[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      child_allowed_children=$(sed -n '/"allowedChildren":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
    
    # Check each child allowedChildren dependency against parent allowedChildren
    if [ -n "$child_allowed_children" ]; then
      IFS='|' read -ra CHILD_ALLOWED_CHILDREN <<< "$child_allowed_children"
      
      for child_dep in "${CHILD_ALLOWED_CHILDREN[@]}"; do
        # Use exact match with pipe delimiters as word boundaries
        if echo "|$parent_allowed_children|" | grep -q "|$child_dep|"; then
          echo "❌ Redundant allowedChildren in $subsystem_name:" >> "/tmp/redundant_allowed_children_$$"
          echo "  🔸 '$child_dep' is already provided by parent allowedChildren" >> "/tmp/redundant_allowed_children_$$"
          echo "     → Remove from $deps_file 'allowedChildren' array" >> "/tmp/redundant_allowed_children_$$"
          echo "     → Parent allowedChildren automatically cascades to children" >> "/tmp/redundant_allowed_children_$$"
          echo "" >> "/tmp/redundant_allowed_children_$$"
        fi
      done
    fi
  fi
done

# Check for hierarchical redundancy (child declaring sub-paths of parent allowedChildren)
echo "Checking for hierarchical redundancy..."
find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  parent_dir=$(dirname "$subsystem_dir")
  
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Get parent's allowedChildren
  parent_deps_file="$parent_dir/dependencies.json"
  parent_allowed_children=""
  if [ -f "$parent_deps_file" ]; then
    if command -v jq >/dev/null 2>&1; then
      parent_allowed_children=$(jq -r '.allowedChildren[]?' "$parent_deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      parent_allowed_children=$(grep -A 20 '"allowedChildren"' "$parent_deps_file" | grep -o '"[^"]*"' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
  fi
  
  # If parent has allowedChildren, check child's dependencies for hierarchical redundancy
  if [ -n "$parent_allowed_children" ]; then
    # Get all child dependencies (both allowed and allowedChildren)
    child_all_deps=""
    if command -v jq >/dev/null 2>&1; then
      child_allowed=$(jq -r '.allowed[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
      child_allowed_children=$(jq -r '.allowedChildren[]?' "$deps_file" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
    else
      child_allowed=$(sed -n '/"allowed":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
      child_allowed_children=$(sed -n '/"allowedChildren":/,/\]/p' "$deps_file" | grep -o '    "[^"]*"' | sed 's/[[:space:]]*"//g' | sed 's/"//g' | tr '\n' '|' | sed 's/|$//')
    fi
    
    # Combine both arrays
    if [ -n "$child_allowed" ] && [ -n "$child_allowed_children" ]; then
      child_all_deps="$child_allowed|$child_allowed_children"
    elif [ -n "$child_allowed" ]; then
      child_all_deps="$child_allowed"
    elif [ -n "$child_allowed_children" ]; then
      child_all_deps="$child_allowed_children"
    fi
    
    # Check each child dependency against parent allowedChildren for hierarchical matches
    if [ -n "$child_all_deps" ]; then
      IFS='|' read -ra CHILD_ALL_DEPS <<< "$child_all_deps"
      IFS='|' read -ra PARENT_ALLOWED_CHILDREN <<< "$parent_allowed_children"
      
      for child_dep in "${CHILD_ALL_DEPS[@]}"; do
        for parent_dep in "${PARENT_ALLOWED_CHILDREN[@]}"; do
          # Check if child dependency starts with parent dependency
          case "$child_dep" in
            "$parent_dep"/*)
              # Child is a sub-path of parent allowedChildren
              # But check if it's a subsystem that needs explicit permission
              potential_subsystem_path=""
              if [[ "$parent_dep" == ~/* ]]; then
                # Convert ~/path to src/path for file system checking
                parent_fs_path="src/${parent_dep#\~/}"
                child_suffix="${child_dep#$parent_dep/}"
                potential_subsystem_path="$parent_fs_path/$child_suffix"
              else
                potential_subsystem_path="$parent_dep/${child_dep#$parent_dep/}"
              fi
              
              # If child path is NOT a subsystem, it's redundant
              if [ ! -f "$potential_subsystem_path/dependencies.json" ]; then
                # Determine which array the dependency is in
                dep_array="unknown"
                if echo "|$child_allowed|" | grep -q "|$child_dep|"; then
                  dep_array="allowed"
                elif echo "|$child_allowed_children|" | grep -q "|$child_dep|"; then
                  dep_array="allowedChildren"
                fi
                
                echo "❌ Hierarchical redundancy in $subsystem_name:" >> "/tmp/hierarchical_redundancy_$$"
                echo "  🔸 '$child_dep' is covered by parent's '$parent_dep'" >> "/tmp/hierarchical_redundancy_$$"
                echo "     → Remove from $deps_file '$dep_array' array" >> "/tmp/hierarchical_redundancy_$$"
                echo "     → Parent allowedChildren '$parent_dep' already allows access to sub-paths" >> "/tmp/hierarchical_redundancy_$$"
                echo "" >> "/tmp/hierarchical_redundancy_$$"
              fi
              ;;
          esac
        done
      done
    fi
  fi
done

# Read redundant dependencies file and add to ERRORS
if [ -f "/tmp/redundant_deps_$$" ]; then
  redundant_errors=$(cat "/tmp/redundant_deps_$$")
  if [ -n "$redundant_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$redundant_errors"
  fi
  rm -f "/tmp/redundant_deps_$$"
fi

# Read redundant allowedChildren file and add to ERRORS
if [ -f "/tmp/redundant_allowed_children_$$" ]; then
  redundant_allowed_children_errors=$(cat "/tmp/redundant_allowed_children_$$")
  if [ -n "$redundant_allowed_children_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$redundant_allowed_children_errors"
  fi
  rm -f "/tmp/redundant_allowed_children_$$"
fi

# Read hierarchical redundancy file and add to ERRORS
if [ -f "/tmp/hierarchical_redundancy_$$" ]; then
  hierarchical_redundancy_errors=$(cat "/tmp/hierarchical_redundancy_$$")
  if [ -n "$hierarchical_redundancy_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$hierarchical_redundancy_errors"
  fi
  rm -f "/tmp/hierarchical_redundancy_$$"
fi

# Check hierarchical dependency violations
echo "Checking hierarchical dependencies..."

# Helper function to count path depth (number of ../ segments)
count_path_depth() {
  local path="$1"
  echo "$path" | grep -o "\.\.\/" | wc -l
}

# Helper function to check if a path goes beyond direct children
is_hierarchical_violation() {
  local import_path="$1"
  local subsystem_dir="$2"
  
  # Skip non-relative imports
  case "$import_path" in
    "../"*)
      # PHILOSOPHY: 
      # - Going UP the hierarchy (../../../parent) is ALWAYS allowed
      # - Going DOWN/ACROSS to grandchildren (../sibling/grandchild) is FORBIDDEN
      
      # Check if path goes DOWN after going UP
      # Pattern: ../[directory]/[directory] means "go up, then down into sibling, then down into grandchild"
      # But ../../.. or ../../../types means "just go up multiple levels" which is fine
      
      # Remove all leading ../ segments to see what's left
      local path_after_ups=$(echo "$import_path" | sed 's|^\(\.\./\)*||')
      
      # If what's left contains multiple directory levels, it's going down through grandchildren
      # Count slashes in the remaining path - more than 1 slash means multiple levels down
      local slash_count=$(echo "$path_after_ups" | tr -cd '/' | wc -c)
      
      if [ "$slash_count" -gt 1 ]; then
        return 0  # Is a violation - going down through multiple subsystem levels
      fi
      ;;
  esac
  
  return 1  # Not a violation
}

# Helper function to resolve relative import paths to absolute paths
resolve_import_path() {
  local import_path="$1"
  local current_subsystem_dir="$2"
  
  # If already absolute path with ~/, return as-is
  if echo "$import_path" | grep -q "^~/"; then
    echo "$import_path"
    return
  fi
  
  # Resolve relative path
  if echo "$import_path" | grep -q "^\.\."; then
    # Get the absolute path of the current subsystem
    local abs_current=$(cd "$current_subsystem_dir" && pwd)
    # Remove the src/ prefix and add ~/
    local relative_current=$(echo "$abs_current" | sed 's|.*/src/|~/|')
    
    # Count ../ segments
    local up_count=$(echo "$import_path" | grep -o "\.\.\/" | wc -l)
    
    # Remove ../ segments from current path
    local resolved_base="$relative_current"
    for i in $(seq 1 $up_count); do
      resolved_base=$(dirname "$resolved_base")
    done
    
    # Add the remaining path after ../
    local remaining_path=$(echo "$import_path" | sed 's|\.\./||g')
    if [ -n "$remaining_path" ]; then
      echo "$resolved_base/$remaining_path"
    else
      echo "$resolved_base"
    fi
  else
    # Relative path without ../ - should not happen in outbound imports
    echo "$import_path"
  fi
}

# Helper function to check if import is allowed by dependencies.json
is_import_allowed() {
  local import_path="$1"
  local deps_file="$2"
  
  # Read allowed dependencies from JSON
  local allowed_deps=""
  if command -v jq >/dev/null 2>&1; then
    allowed_deps=$(jq -r '.allowed[]?' "$deps_file" 2>/dev/null || echo "")
  else
    # Fallback parsing without jq
    allowed_deps=$(grep -o '"[^"]*"' "$deps_file" | grep -A 100 '"allowed"' | grep -v '"allowed"' | head -n 50 | sed 's/"//g' || echo "")
  fi
  
  # Check direct matches
  if echo "$allowed_deps" | grep -q "^${import_path}$"; then
    return 0  # Allowed
  fi
  
  # Check hierarchical matches (if ~/lib/utils is allowed, ~/lib/utils/cn should be allowed)
  while IFS= read -r allowed_dep; do
    if [ -n "$allowed_dep" ] && echo "$import_path" | grep -q "^${allowed_dep}/"; then
      return 0  # Allowed by hierarchy
    fi
  done << EOF
$allowed_deps
EOF
  
  return 1  # Not allowed
}

# Helper function to check if import is allowed by resolved dependencies (pipe-separated)
is_import_allowed_by_resolved() {
  local import_path="$1"
  local resolved_deps="$2"
  
  if [ -z "$resolved_deps" ]; then
    return 1  # No dependencies resolved
  fi
  
  # Check direct match using pipe delimiters
  if echo "|$resolved_deps|" | grep -q "|$import_path|"; then
    return 0  # Exact match found
  fi
  
  # Check hierarchical matches (if ~/lib/utils is allowed, ~/lib/utils/something should be allowed)
  IFS='|' read -ra DEPS <<< "$resolved_deps"
  for allowed_dep in "${DEPS[@]}"; do
    if [ -n "$allowed_dep" ]; then
      # Handle both ~/path and ~/path/ forms
      local normalized_dep="${allowed_dep%/}"  # Remove trailing slash if present
      if echo "$import_path" | grep -q "^${normalized_dep}/"; then
        return 0  # Allowed by hierarchy
      fi
    fi
  done
  
  return 1  # Not allowed
}

# Helper function to find the top-level subsystem containing a path
find_top_level_subsystem() {
  local target_path="$1"
  local original_target="$target_path"
  
  # Convert ~/path to src/path for file system checking
  if [[ "$target_path" == \~/* ]]; then
    target_path="${target_path/\~\//src/}"
  fi
  
  # Special handling for major areas - look for the top-level subsystem
  # For src/app/map/... paths, we want to find src/app/map as the boundary
  # For src/lib/... paths, we want to find src/lib as the boundary
  
  # Check specific patterns for known top-level subsystems
  case "$target_path" in
    src/app/map/*)
      if [ -f "src/app/map/dependencies.json" ]; then
        echo "src/app/map"
        return 0
      fi
      ;;
    src/lib/*)
      # For lib, the first level is the boundary (src/lib/domains, src/lib/utils, etc.)
      echo "$target_path" | sed 's|^src/lib/\([^/]*\).*|src/lib/\1|'
      return 0
      ;;
    src/commons/*)
      echo "$target_path" | sed 's|^src/commons/\([^/]*\).*|src/commons/\1|'
      return 0
      ;;
    src/components/*)
      echo "src/components"
      return 0
      ;;
  esac
  
  # Fallback: find the nearest subsystem by walking up
  local current_dir="$target_path"
  while [ "$current_dir" != "src" ] && [ "$current_dir" != "/" ] && [ "$current_dir" != "." ]; do
    if [ -f "$current_dir/dependencies.json" ]; then
      echo "$current_dir"
      return 0
    fi
    current_dir=$(dirname "$current_dir")
  done
  
  # Final fallback: return the immediate child of src
  if [[ "$target_path" == src/* ]]; then
    echo "$target_path" | sed 's|^src/\([^/]*\).*|src/\1|'
  else
    echo "$original_target"
  fi
}

# Helper function to check if an import is truly outbound (crosses subsystem boundaries)
is_truly_outbound() {
  local import_path="$1"
  local current_subsystem_dir="$2"
  
  # Skip non-absolute imports (relative imports like ../ are handled separately)
  if [[ "$import_path" != \~/* ]]; then
    return 0  # Consider relative imports as potentially outbound
  fi
  
  # Find the top-level subsystem containing the current file
  local current_top_subsystem=$(find_top_level_subsystem "$current_subsystem_dir")
  
  # Find the top-level subsystem containing the import target
  local import_target_subsystem=$(find_top_level_subsystem "$import_path")
  
  # If both are in the same top-level subsystem, it's internal
  if [ "$current_top_subsystem" = "$import_target_subsystem" ]; then
    return 1  # Not outbound - internal to same subsystem
  fi
  
  return 0  # Truly outbound - crosses subsystem boundaries
}

# Check outbound dependencies against allowlist
echo "Checking outbound dependencies..."

find_subsystems | while read subsystem_dir; do
  subsystem_name=$(basename "$subsystem_dir")
  deps_file="$subsystem_dir/dependencies.json"
  parent_dir=$(dirname "$subsystem_dir")
  
  # Skip if no dependencies.json
  if [ ! -f "$deps_file" ]; then
    continue
  fi
  
  # Get full inheritance chain of allowedChildren from all ancestors
  full_inherited_allowedchildren=$(resolve_full_inheritance_chain "$subsystem_dir")
  
  # Resolve all allowed dependencies (local + inherited from full chain)
  resolved_allowed_deps=$(resolve_allowed_dependencies "$deps_file" "$full_inherited_allowedchildren")
  
  # Find all TypeScript files in the subsystem
  for ts_file in $(find "$subsystem_dir" -name "*.ts" -o -name "*.tsx" | grep -v "__tests__" | grep -v ".test.ts" | grep -v ".spec.ts"); do
    # Find imports that go outside the subsystem
    outbound_imports=$(grep -n "from [\"']\.\./\|from [\"']~/" "$ts_file" 2>/dev/null || true)
    
    if [ -n "$outbound_imports" ]; then
      echo "$outbound_imports" | while IFS= read -r import_line; do
        if [ -n "$import_line" ]; then
          line_num=$(echo "$import_line" | cut -d: -f1)
          import_path=$(echo "$import_line" | sed "s/.*from [\"']\([^\"']*\)[\"'].*/\1/")
          
          # Skip internal imports that don't cross subsystem boundaries
          if ! is_truly_outbound "$import_path" "$subsystem_dir"; then
            continue  # Skip this import - it's internal to the same top-level subsystem
          fi
          
          # Check if this is a hierarchical violation
          if is_hierarchical_violation "$import_path" "$subsystem_dir"; then
            relative_file=$(echo "$ts_file" | sed "s|^$subsystem_dir/||")
            echo "⚠️ Hierarchical dependency violation in $subsystem_name:" >> "/tmp/hierarchical_errors_$$"
            echo "  🔸 $relative_file:$line_num" >> "/tmp/hierarchical_errors_$$"
            echo "     import from '$import_path'" >> "/tmp/hierarchical_errors_$$"
            echo "     → This imports from a grandchild subsystem. Create reexports in intermediate subsystems." >> "/tmp/hierarchical_errors_$$"
            echo "" >> "/tmp/hierarchical_errors_$$"
          fi
          
          # Check if this import is allowed by resolved dependencies (local + inherited)
          resolved_path=$(resolve_import_path "$import_path" "$subsystem_dir")
          if ! is_import_allowed_by_resolved "$resolved_path" "$resolved_allowed_deps"; then
            relative_file=$(echo "$ts_file" | sed "s|^$subsystem_dir/||")
            echo "❌ Undeclared outbound dependency in $subsystem_name:" >> "/tmp/dependency_errors_$$"
            echo "  🔸 $relative_file:$line_num" >> "/tmp/dependency_errors_$$"
            echo "     import from '$import_path' → resolves to '$resolved_path'" >> "/tmp/dependency_errors_$$"
            echo "     → Add '$resolved_path' to dependencies.json 'allowed' array" >> "/tmp/dependency_errors_$$"
            echo "     → Or ensure parent allowedChildren includes this dependency" >> "/tmp/dependency_errors_$$"
            echo "" >> "/tmp/dependency_errors_$$"
          fi
        fi
      done
    fi
  done
done

# Read hierarchical error file and add to ERRORS
if [ -f "/tmp/hierarchical_errors_$$" ]; then
  hierarchical_errors=$(cat "/tmp/hierarchical_errors_$$")
  if [ -n "$hierarchical_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$hierarchical_errors"
  fi
  rm -f "/tmp/hierarchical_errors_$$"
fi

# Read dependency error file and add to ERRORS
if [ -f "/tmp/dependency_errors_$$" ]; then
  dependency_errors=$(cat "/tmp/dependency_errors_$$")
  if [ -n "$dependency_errors" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$dependency_errors"
  fi
  rm -f "/tmp/dependency_errors_$$"
fi

# Check for file/folder naming conflicts
echo "Checking for file/folder naming conflicts..."
check_file_folder_conflicts "$TARGET_PATH"

# Read naming conflicts file and add to ERRORS
if [ -f "/tmp/naming_conflicts_$$" ]; then
  naming_conflicts=$(cat "/tmp/naming_conflicts_$$")
  if [ -n "$naming_conflicts" ]; then
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}$naming_conflicts"
  fi
  rm -f "/tmp/naming_conflicts_$$"
fi

# Validate domain-specific structure
echo "Checking domain structure..."
for domain_dir in $(find "$TARGET_PATH/lib/domains" -mindepth 1 -maxdepth 1 -type d 2>/dev/null); do
  validate_domain_structure "$domain_dir"
done

# Check domain import restrictions
echo "Checking domain import restrictions..."
find "$TARGET_PATH/lib/domains" -path "*/services/*.ts" -not -name "index.ts" 2>/dev/null | while read service_file; do
  # Find files that import this service (should only be API/server files)
  service_imports=$(find src -name "*.ts" -o -name "*.tsx" | \
    xargs grep -l "from.*$(echo "$service_file" | sed 's/.*domains/domains/' | sed 's/\.ts$//')" 2>/dev/null | \
    grep -v "^src/app/api/" | \
    grep -v "^src/server/" | \
    grep -v "$service_file" || true)
  
  if [ -n "$service_imports" ]; then
    service_name=$(basename "$service_file" .ts)
    ERRORS="${ERRORS}${NEWLINE}${NEWLINE}❌ Service $service_name imported by non-API files:"
    while IFS= read -r importing_file; do
      if [ -n "$importing_file" ]; then
        ERRORS="${ERRORS}${NEWLINE}  🔸 $importing_file"
        ERRORS="${ERRORS}${NEWLINE}     → Services can only be imported by API/server code"
      fi
    done << EOF
$service_imports
EOF
  fi
done

# Report results
if [ -n "$ERRORS" ]; then
  echo ""
  echo "🚨 Architecture violations:"
  echo "════════════════════════════════════════════════════════════════════════"
  printf "%s\n" "$ERRORS"
  echo ""
  echo "📋 Requirements:"
  echo "────────────────────────────────────────────────────────────────────────"
  echo "• Folders over $COMPLEXITY_THRESHOLD lines need:"
  echo "  - dependencies.json"
  echo "  - README.md"
  echo "  - ARCHITECTURE.md"
  echo ""
  echo "• File/folder naming conflicts:"
  echo "  - If both types.ts and types/ exist, move types.ts content to types/index.ts"
  echo "  - This prevents ambiguous imports and follows the index pattern"
  echo ""
  echo "• Dependencies.json format:"
  echo "  - All paths in 'allowed' array must use absolute paths with ~/ prefix"
  echo "  - Only 'subsystems' array may use relative paths (./subfolder)"
  echo "  - Example: \"~/lib/utils\" not \"../utils\" or \"./utils\""
  echo ""
  echo "• Subsystems with dependencies.json must be declared in their parent's \"subsystems\" array"
  echo "• Subsystems must be imported through their index.ts (renamed from interface.ts)"
  echo "• External imports should use: import { X } from '~/path/to/subsystem' (automatically uses index.ts)"
  echo "• Child subsystems cannot redeclare dependencies from parent allowedChildren"
  echo "  - allowedChildren cascade automatically to all children"
  echo "  - Use allowedChildren for external tools/libraries shared by multiple children"
  echo "  - Use allowed for subsystem-specific dependencies only"
  echo "• Domain services can only be imported by API/server code"
  echo "• Domain utils can be imported by anyone"
  echo "════════════════════════════════════════════════════════════════════════"
  exit 1
fi

if [ -n "$WARNINGS" ]; then
  echo ""
  echo "⚠️  Warnings:"
  echo "────────────────────────────────────────────────────────────────────────"
  printf "%s\n" "$WARNINGS"
  echo "────────────────────────────────────────────────────────────────────────"
fi

echo "✅ Architecture check passed!"