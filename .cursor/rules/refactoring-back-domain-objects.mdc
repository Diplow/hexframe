---
description: Refactoring domain objects
globs: src/lib/domains/**/objects/*.ts
alwaysApply: false
---
---
description: Refactoring domain objects
globs: src/lib/domains/**/objects/*.ts
alwaysApply: false
---
# Domain Objects Refactoring Guidelines

## Overview
When refactoring domain objects, it's critical to maintain a consistent application structure. Domain object refactoring includes operations like moving objects between domains, renaming entities, changing inheritance patterns, or modifying attribute structures. These changes can have cascading effects throughout the codebase.

## Critical Update Checklist
- **Index Files**: Always update `objects/index.ts` (or `index.js`) files in affected domains
- **Import Statements**: Update all import statements in files that reference the moved/renamed objects
- **Service Implementations**: Check and update domain services that use the refactored objects
- **Adapters and Contracts Implementations**: Check and update domain services adapters and contracts that use the refactored objects.
- **Repository Implementations**: Update repositories that handle persistence for the refactored objects
- **API Routers**: Update tRPC routers that depend on the refactored domain objects
- **Middleware**: Update middleware implementations that use the refactored objects

## Index Files Maintenance
- Every domain's `objects` directory should contain an index file that exports all entities
- When moving objects between domains, update both the source and destination index files
- When renaming entities, ensure the index file exports the entity with its new name
- Make sure to remove exports for deleted entities
- Add exports for newly created entities

## Index File Example
```typescript
// Before refactoring
// src/lib/domains/mapping/objects/index.ts
export * from "./content-entity";
export * from "./author-entity";
export * from "./event-entity";
export * from "./owner-entity";

// After moving content entities to ideas domain
// src/lib/domains/mapping/objects/index.ts
export * from "./map-item-aggregate";
export * from "./owner-entity";

// New index file in ideas domain
// src/lib/domains/ideas/objects/index.ts
export * from "./content-aggregate";
export * from "./author-entity";
export * from "./event-entity";
```


## Strict Domain Isolation
- Domains should be completely isolated with no cross-domain references
- Never import entities or types from one domain into another domain
- Each domain should define its own simplified versions of entities it needs to reference
- The tRPC API layer is solely responsible for composing data from multiple domains
- Communication between domains should happen through the API layer, not directly

```typescript
// Incorrect - referencing another domain
import { ContentAggregate } from "~/lib/domains/ideas/objects/content-aggregate";

// Correct - defining a local representation within the domain
export interface ContentReference {
  id: number;
  title: string;
}

// Correct - API layer composing from multiple domains
router.query("getMapWithContent", async () => {
  const mapItems = await mapService.getMapItems();
  const contentIds = mapItems
    .filter(item => item.reference.type === "content")
    .map(item => item.reference.id);
  const contents = await contentService.getContentsByIds(contentIds);
  
  return { mapItems, contents };
});
```

## Identifying Refactoring Operations
The following operations should trigger this refactoring process:
- Moving entities between domains
- Renaming entities or attributes
- Changing inheritance patterns (e.g., from Entity to Aggregate)
- Splitting entities or merging entities
- Changing relationship patterns between entities

## Testing After Refactoring
- Run TypeScript type checking to identify type errors
- Verify all index files correctly export the refactored entities
- Test affected API endpoints to ensure they still function correctly
- Check for circular dependencies that might have been introduced