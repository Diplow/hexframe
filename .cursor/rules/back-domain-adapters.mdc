---
description: Implementing domain's services adapters.
globs: src/lib/domains/**/services/adapters.ts
alwaysApply: false
---
---
description: Implementing domain's services adapters.
globs: src/lib/domains/**/services/adapters.ts
alwaysApply: false
---
# Domain Service Adapters Pattern

## Structure and Organization
- Create adapters in a dedicated file named `adapters.ts` within the service directory
- Export all adapters through a single object named `adapters`
- Export contract types derived from adapter return types
- Adapters should transform domain objects to data transfer objects (DTOs/contracts)

## Naming Conventions
- Adapter functions should follow the pattern: `{entityName}Adapter`
- Contract types should follow the pattern: `{EntityName}Contract`
- Export the adapter object as `adapters` with methods named after the entity

## Adapter Implementation
- Adapters should:
  1. Accept a domain entity/aggregate as input
  2. Return a plain JavaScript object (contract/DTO)
  3. Transform all domain-specific types to primitive types
  4. Convert IDs to strings for external consumption
  5. Format dates as ISO strings
  6. Handle nested entities by calling their respective adapters

## Type Definitions
- Define contract types using TypeScript's `ReturnType` utility:
  - `export type EntityContract = ReturnType<typeof entityAdapter>;`
- Export all contract types for use in service return types

## Composition Pattern
- For nested entities, compose adapters:
  - Call child entity adapters within parent adapters
  - Map collections of entities using array methods

## Example Structure
```typescript
import type { EntityAggregate, ChildEntity } from "../objects";

const childAdapter = (entity: ChildEntity) => {
  return {
    id: String(entity.data.id),
    name: entity.data.name,
    // Other primitive properties
  };
};

export type ChildContract = ReturnType<typeof childAdapter>;

const entityAdapter = (entity: EntityAggregate) => {
  return {
    id: String(entity.data.id),
    name: entity.data.name,
    createdAt: entity.data.createdAt.toISOString(),
    updatedAt: entity.data.updatedAt.toISOString(),
    // Transform domain-specific types to primitives
    // Call child adapters for nested entities
    children: entity.children.map(childAdapter),
  };
};

export type EntityContract = ReturnType<typeof entityAdapter>;

export const adapters = {
  entity: entityAdapter,
  child: childAdapter,
};
```

## Key Principles
- Adapters create a clear boundary between domain and external representations
- Domain objects should never leak outside the domain layer
- Contracts/DTOs should use primitive types suitable for serialization
- IDs should be converted to strings for external API consistency
- Dates should be formatted as ISO strings
- Complex domain types should be simplified for external consumption
- Adapters should be pure functions with no side effects