---
description: Testing a domain service
globs: src/lib/domains/**/services/*.test.ts
alwaysApply: false
---
---
description: Testing a domain service
globs: src/lib/domains/**/services/*.test.ts
alwaysApply: false
---
# Domain Service Testing Pattern

## Test Structure and Organization
- Create test files with naming pattern: `{entity}-service.test.ts`
- Place test files in the same directory as the service being tested
- Use Vitest (or Jest) for testing framework
- Structure tests using describe/it blocks for clear organization
- Group tests by service method

## Test Setup
- Import the service and its dependencies
- Use in-memory repository implementations for tests
- Create a fresh instance of the service for each test suite
- Reset repository state in `beforeEach` to ensure test isolation
- Initialize test data within individual test cases

## Test Coverage Requirements
- Test all public methods of the service
- Include both success and error cases for each method
- Test validation logic and error handling
- Test pagination functionality where applicable
- Verify that service methods return contracts, not domain objects

## Assertion Patterns
- Use explicit equality checks with `toEqual` for object comparison
- Use `expect.any(String)` for dynamic values like timestamps
- Verify that created/updated entities persist by retrieving them again
- For error cases, use `await expect(promise).rejects.toThrow()`
- Test that error messages are descriptive and specific

## Test Case Organization
- Group tests by service method using nested `describe` blocks
- Name test cases descriptively using the "it should..." pattern
- Test the main success path first, then edge cases and error cases
- For CRUD operations, follow a consistent testing order:
  1. Create
  2. Get/Retrieve
  3. Update
  4. Delete

## Example Structure
```typescript
import { describe, it, expect, beforeEach } from "vitest";
import { EntityAggregateRepository } from "~/lib/infrastructure/entity/repositories/entity-memory-repository";
import { EntityService } from "~/lib/domains/entity/services";

describe("EntityService", () => {
  const repository = new EntityAggregateRepository();
  const service = new EntityService(repository);

  beforeEach(() => {
    repository.reset();
  });

  describe("create", () => {
    it("should create an entity with valid data", async () => {
      const entity = await service.create("Test Entity", "1");
      
      expect(entity).toEqual({
        id: expect.any(String),
        name: "Test Entity",
        owner: { id: "1" },
        createdAt: expect.any(String),
        updatedAt: expect.any(String),
      });
    });
    
    it("should throw an error with invalid data", async () => {
      await expect(service.create("", "1")).rejects.toThrow("Invalid name");
    });
  });
  
  describe("getOne", () => {
    it("should retrieve an entity by id", async () => {
      // Test implementation
    });
    
    it("should throw an error if entity not found", async () => {
      // Test implementation
    });
  });
  
  // Additional method tests...
});
```

## Key Principles
- Tests should be independent and isolated
- Use in-memory repositories to avoid external dependencies
- Reset state between tests to prevent test pollution
- Test both happy paths and error cases
- Verify that validation logic is enforced
- Ensure that service methods return contracts with expected structure
- Test that IDs are properly converted to strings in returned contracts
- Verify that dates are properly formatted as ISO strings