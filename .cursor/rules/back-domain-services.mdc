---
description: Implementing domain services
globs: src/lib/domain/**/services/*service.ts
alwaysApply: false
---
---
description: Implementing domain services
globs: src/lib/domain/**/services/*service.ts
alwaysApply: false
---
# Domain Service Pattern Implementation Guidelines

## Service Structure
- Create a service class named with the pattern: `{Entity}Service`
- Services should encapsulate domain logic and validation
- Services should depend on repositories and domain actions
- Use private readonly properties for dependencies
- Initialize domain actions in the constructor

## Implementation Pattern
- Services should:
  1. Accept repositories via constructor dependency injection
  2. Expose public methods that represent use cases
  3. Validate inputs before delegating to domain actions
  4. Transform domain objects to contracts/DTOs using adapters
  5. Contain static validation methods for reusable validation logic

## Service-Actions Relationship
- Services should instantiate actions in their constructor
- Store actions as a private readonly property: `private readonly actions: EntityActions`
- Services delegate complex business logic to actions
- Actions should never be exposed outside the service

## Method Guidelines
- Public methods should:
  - Accept primitive types or simple objects as parameters
  - Return contract/DTO objects (never domain objects directly)
  - Handle input validation
  - Delegate business logic to domain actions
  - Transform domain objects to contracts using adapters

## Validation Methods
- Create private static methods for validation logic
- Validate IDs, pagination parameters, and input data
- Throw descriptive error messages for invalid inputs
- Apply business rules consistently

## Example Structure
```typescript
export class EntityService {
  private readonly actions: EntityActions;

  constructor(private readonly repository: EntityRepository) {
    this.actions = new EntityActions(repository);
  }

  public async getOne(id: string): Promise<EntityContract> {
    const validatedId = EntityService.validateAndParseId(id);
    return adapters.entity(await this.actions.getOne(validatedId));
  }

  public async create(/* parameters */): Promise<EntityContract> {
    // Validate inputs
    // Delegate to actions
    // Return adapted result
  }

  private static validateAndParseId(id: string): number {
    // Validation logic
  }
}
```

## Key Principles
- Maintain separation of concerns
- Enforce domain validation at service boundaries
- Transform between domain objects and contracts/DTOs
- Keep domain objects encapsulated within the domain layer
- Use static methods for reusable validation logic