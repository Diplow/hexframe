---
description: Coding domain repositories
globs: src/lib/domains/*/repositories/*.ts
alwaysApply: false
---
---
description: Coding domain repositories
globs: src/lib/domains/*/repositories/*.ts
alwaysApply: false
---
# Domain Repository Interface Pattern

## Naming Conventions
- Interface names should follow the pattern: `{DomainObject}Repository`
  - Use the domain object name without qualifications (e.g., `MapRepository` for `MapAggregate`)
- File names should use kebab-case: `{domain-object}-repository.ts`
  - Example: `map-repository.ts` for `MapRepository`

## Interface Structure
- Repositories should define interfaces only, not implementations
- All repository methods should return Promise-wrapped domain objects
- Return types should be domain aggregates or collections of domain aggregates
- For collection returns, use arrays of domain aggregates: `Promise<EntityAggregate[]>`
- For single entity returns, use the domain aggregate: `Promise<EntityAggregate>`
- For removal operations, use `Promise<void>`

## Method Signatures
- Method parameters should use:
  - Primitive types (number, string, boolean)
  - Domain value objects
  - Domain entity attributes
  - Simple parameter objects with primitive properties
- ID parameters should be named with the pattern: `{entityName}Id`
- Collection methods should support pagination with `limit` and `offset` parameters
- Update methods should accept an ID and a partial data object

## Standard Methods
- `getOne(id: number): Promise<EntityAggregate>`
- `getMany(limit?: number, offset?: number): Promise<EntityAggregate[]>`
- `create(...): Promise<EntityAggregate>`
- `update(id: number, data: Partial<EntityAttributes>): Promise<EntityAggregate>`
- `remove(id: number): Promise<void>`

## Import Rules
- Repository interfaces should only import domain objects
- No infrastructure or framework imports allowed
- No service or application layer imports allowed

## Example Structure
```typescript
import { EntityAggregate, RelatedEntityAttributes } from "../objects";

export interface EntityRepository {
  getOne(entityId: number): Promise<EntityAggregate>;
  getMany(limit?: number, offset?: number): Promise<EntityAggregate[]>;
  getByRelatedId(
    relatedId: string,
    limit?: number, 
    offset?: number
  ): Promise<EntityAggregate[]>;
  create(
    name: string,
    description: string | null,
    related: RelatedEntityAttributes,
    options?: Record<string, any>
  ): Promise<EntityAggregate>;
  update(
    entityId: number,
    data: Partial<EntityAttributes>
  ): Promise<EntityAggregate>;
  remove(entityId: number): Promise<void>;
}
```

## Key Principles
- Repository interfaces define contracts, not implementations
- Keep domain repositories independent of infrastructure concerns
- Maintain clear separation between domain and infrastructure layers
- Repository methods should work with domain objects, not DTOs or contracts
- Repository interfaces belong to the domain layer