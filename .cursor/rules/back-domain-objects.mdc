---
description: Implementing domain objects
globs: src/lib/domains/*/objects/*.ts
alwaysApply: false
---
---
description: Implementing domain objects
globs: src/lib/domains/*/objects/*.ts
alwaysApply: false
---
# Domain Objects Pattern

## Class Hierarchy
- Use a consistent inheritance hierarchy for domain objects
- Implement `GenericEntity` for simple entities without relationships
- Implement `GenericAggregate` for aggregates with relationships
- All domain objects should extend one of these base classes

## Naming Conventions
- Name aggregate classes with the pattern: `{Entity}Aggregate`
- Name entity classes with the pattern: `{Entity}Entity`
- Name attribute interfaces with the pattern: `{Entity}Attributes` or `{Entity}EntityAttributes`
- Place domain objects in a dedicated `objects` directory within the domain

## Attributes Definition
- Define a separate interface for entity attributes
- Extend `GenericEntityData` for all attribute interfaces
- Include all primitive properties in the attributes interface
- Use proper TypeScript types (avoid `any` where possible)
- Document complex attributes with comments

## Relationship Management
- Aggregates should expose relationships as named properties
- Store single relationships in `relatedItems` with consistent naming
- Store collections in `relatedLists` with consistent naming
- Pass relationships to the parent constructor in the proper format
- Expose relationships as strongly-typed properties
- As a general rule:
  - Database foreign keys (one-to-one or many-to-one) should map to `relatedItems` in the domain
  - Database relations (one-to-many or many-to-many) should map to `relatedLists` in the domain
  - For example, a Content entity with an authorId foreign key would have an "author" relatedItem in its domain object

## Database to Domain Mapping
- When converting from database entities to domain objects:
  - Primary entities become domain entities or aggregates based on relationships
  - Foreign key fields (e.g., authorId, ownerId) become referenced entities in `relatedItems`
  - Join tables or one-to-many relations become collections in `relatedLists`
  - Example: If a Content has an authorId in the database, the ContentAggregate would have an "author" in relatedItems
  - Example: If Events relate to Content through a join table, the ContentAggregate would have "mentionedEvents" in relatedLists


## Constructor Pattern
- Accept attributes as the first parameter
- Accept related entities as subsequent parameters
- Initialize the parent class with proper relationship mappings
- Set default values for optional relationships
- Normalize data in the constructor (e.g., null handling)

## Validation Logic
- Implement static validation methods for entity attributes
- Name validation methods with the pattern: `validate{Attribute}`
- Throw descriptive error messages for validation failures
- Call validation methods from services before creating/updating entities

## Example Structure
```typescript
import { GenericAggregate, GenericEntityData } from "../utils/generic-objects";
import { ChildEntity } from "./child-entity";

export interface EntityAttributes extends GenericEntityData {
  id: number;
  name: string;
  description: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export class EntityAggregate extends GenericAggregate {
  readonly data: EntityAttributes;
  readonly children: ChildEntity[];

  constructor(
    data: EntityAttributes,
    children: ChildEntity[] = [],
  ) {
    super(data, {}, { children });
    this.data = {
      ...data,
      description: data.description ?? null,
    };
    this.children = children;
  }

  public static validateName(name: string) {
    if (!name || name.length < 3) {
      throw new Error("Invalid name: must be at least 3 characters long");
    }
  }
}
```

## Key Principles
- Domain objects should be immutable (use readonly properties)
- Domain objects should encapsulate business rules and validation
- Aggregates manage relationships between entities
- Entities represent individual domain objects
- Validation logic should be centralized in the domain objects
- Domain objects should be independent of infrastructure concerns
- Use static methods for validation and factory functions
- Normalize data in the constructor to ensure consistency
